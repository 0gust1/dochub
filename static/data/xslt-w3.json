[
	{
		"url": "http://www.w3.org/TR/xslt",
		"title": "XSLT",
		"html": "<div class = \"head\">\n<a href = \"http://www.w3.org/\"><img src = \"http://www.w3.org/Icons/WWW/w3c_home\" alt = \"W3C\" height = \"48\" width = \"72\"/></a>\n\n<h1>XSL Transformations (XSLT)<br/>\nVersion 1.0</h1>\n\n<h2>W3C Recommendation 16 November 1999</h2>\n<dl>\n  <dt>This version:</dt>\n    <dd><a href = \"http://www.w3.org/TR/1999/REC-xslt-19991116\">http://www.w3.org/TR/1999/REC-xslt-19991116</a>\n      <br/>\n      (available in <a href = \"http://www.w3.org/TR/1999/REC-xslt-19991116.xml\">XML</a> or <a href = \"http://www.w3.org/TR/1999/REC-xslt-19991116.html\">HTML</a>)</dd>\n  <dt>Latest version:</dt>\n    <dd><a href = \"http://www.w3.org/TR/xslt\">http://www.w3.org/TR/xslt</a> <br/>\n    </dd>\n  <dt>Previous versions:</dt>\n    <dd><a href = \"http://www.w3.org/TR/1999/PR-xslt-19991008\">http://www.w3.org/TR/1999/PR-xslt-19991008</a>\n      <br/>\n      <a href = \"http://www.w3.org/1999/08/WD-xslt-19990813\">http://www.w3.org/1999/08/WD-xslt-19990813</a>\n      <br/>\n      <a href = \"http://www.w3.org/1999/07/WD-xslt-19990709\">http://www.w3.org/1999/07/WD-xslt-19990709</a>\n      <br/>\n      <a href = \"http://www.w3.org/TR/1999/WD-xslt-19990421\">http://www.w3.org/TR/1999/WD-xslt-19990421</a>\n      <br/>\n      <a href = \"http://www.w3.org/TR/1998/WD-xsl-19981216\">http://www.w3.org/TR/1998/WD-xsl-19981216</a>\n      <br/>\n      <a href = \"http://www.w3.org/TR/1998/WD-xsl-19980818\">http://www.w3.org/TR/1998/WD-xsl-19980818</a>\n      <br/>\n    </dd>\n  <dt>Editor:</dt>\n    <dd>James Clark <a href = \"mailto:jjc@jclark.com\">&lt;jjc@jclark.com&gt;</a> <br/>\n    </dd>\n</dl>\n\n<p class = \"copyright\"><a href = \"http://www.w3.org/Consortium/Legal/ipr-notice.html#Copyright\">Copyright</a>\n&nbsp;�&nbsp; 1999 <a href = \"http://www.w3.org\">W3C</a><sup>�</sup> (<a href = \"http://www.lcs.mit.edu\">MIT</a>, <a href = \"http://www.inria.fr/\">INRIA</a>, <a href = \"http://www.keio.ac.jp/\">Keio</a>), All Rights Reserved. W3C <a href = \"http://www.w3.org/Consortium/Legal/ipr-notice.html#Legal_Disclaimer\">liability</a>,\n<a href = \"http://www.w3.org/Consortium/Legal/ipr-notice.html#W3C_Trademarks\">trademark</a>,\n<a href = \"http://www.w3.org/Consortium/Legal/copyright-documents.html\">document\nuse</a> and <a href = \"http://www.w3.org/Consortium/Legal/copyright-software.html\">software\nlicensing</a> rules apply.</p>\n<hr title = \"Separator for header\"/>\n</div><h2><a name = \"abstract\" id = \"abstract\">Abstract</a></h2><p>This specification defines the syntax and semantics of XSLT, which is a\nlanguage for transforming XML documents into other XML documents.</p><p>XSLT is designed for use as part of XSL, which is a stylesheet language\nfor XML. In addition to XSLT, XSL includes an XML vocabulary for specifying\nformatting.  XSL specifies the styling of an XML document by using XSLT to\ndescribe how the document is transformed into another XML document that uses\nthe formatting vocabulary.</p><p>XSLT is also designed to be used independently of XSL.  However, XSLT is\nnot intended as a completely general-purpose XML transformation language. \nRather it is designed primarily for the kinds of transformations that are\nneeded when XSLT is used as part of XSL.</p><h2><a name = \"status\" id = \"status\">Status of this document</a></h2><p>This document has been reviewed by W3C Members and other interested\nparties and has been endorsed by the Director as a W3C <a href = \"http://www.w3.org/Consortium/Process/#RecsW3C\">Recommendation</a>. It\nis a stable document and may be used as reference material or cited as a\nnormative reference from other documents. W3C's role in making the\nRecommendation is to draw attention to the specification and to promote its\nwidespread deployment. This enhances the functionality and interoperability\nof the Web.</p><p>The list of known errors in this specification is available at <a href = \"http://www.w3.org/1999/11/REC-xslt-19991116-errata\">http://www.w3.org/1999/11/REC-xslt-19991116-errata</a>.</p><p>Comments on this specification may be sent to <a href = \"mailto:xsl-editors@w3.org\">xsl-editors@w3.org</a>; <a href = \"http://lists.w3.org/Archives/Public/xsl-editors\">archives</a> of the\ncomments are available.  Public discussion of XSL, including XSL\nTransformations, takes place on the <a href = \"http://www.mulberrytech.com/xsl/xsl-list/index.html\">XSL-List</a>\nmailing list.</p><p>The English version of this specification is the only normative version.\nHowever, for translations of this document, see <a href = \"http://www.w3.org/Style/XSL/translations.html\">http://www.w3.org/Style/XSL/translations.html</a>.</p><p>A list of current W3C Recommendations and other technical documents can be\nfound at <a href = \"http://www.w3.org/TR\">http://www.w3.org/TR</a>.</p><p>This specification has been produced as part of the <a href = \"http://www.w3.org/Style/Activity\">W3C Style activity</a>.</p><h2><a name = \"contents\" id = \"contents\">Table of contents</a></h2><a href = \"#section-Introduction\">Introduction</a><br/><a href = \"#section-Stylesheet-Structure\">Stylesheet Structure</a><br/><a href = \"#xslt-namespace\">XSLT Namespace</a><br/><a href = \"#stylesheet-element\">Stylesheet\nElement</a><br/><a href = \"#result-element-stylesheet\">Literal\nResult Element as Stylesheet</a><br/><a href = \"#qname\">Qualified Names</a><br/><a href = \"#forwards\">Forwards-Compatible\nProcessing</a><br/><a href = \"#section-Combining-Stylesheets\">Combining Stylesheets</a><br/><a href = \"#include\">Stylesheet Inclusion</a><br/><a href = \"#import\">Stylesheet Import</a><br/><a href = \"#section-Embedding-Stylesheets\">Embedding Stylesheets</a><br/><a href = \"#data-model\">Data Model</a><br/><a href = \"#root-node-children\">Root Node\nChildren</a><br/><a href = \"#base-uri\">Base URI</a><br/><a href = \"#unparsed-entities\">Unparsed\nEntities</a><br/><a href = \"#strip\">Whitespace Stripping</a><br/><a href = \"#section-Expressions\">Expressions</a><br/><a href = \"#rules\">Template Rules</a><br/><a href = \"#section-Processing-Model\">Processing\nModel</a><br/><a href = \"#patterns\">Patterns</a><br/><a href = \"#section-Defining-Template-Rules\">Defining Template Rules</a><br/><a href = \"#section-Applying-Template-Rules\">Applying Template Rules</a><br/><a href = \"#conflict\">Conflict Resolution for\nTemplate Rules</a><br/><a href = \"#apply-imports\">Overriding Template\nRules</a><br/><a href = \"#modes\">Modes</a><br/><a href = \"#built-in-rule\">Built-in Template\nRules</a><br/><a href = \"#named-templates\">Named Templates</a><br/><a href = \"#section-Creating-the-Result-Tree\">Creating the Result Tree</a><br/><a href = \"#section-Creating-Elements-and-Attributes\">Creating Elements and\nAttributes</a><br/><a href = \"#literal-result-element\">Literal Result Elements</a><br/><a href = \"#section-Creating-Elements-with-xsl:element\">Creating Elements with\nxsl:element</a><br/><a href = \"#creating-attributes\">Creating Attributes with xsl:attribute</a><br/><a href = \"#attribute-sets\">Named Attribute Sets</a><br/><a href = \"#section-Creating-Text\">Creating\nText</a><br/><a href = \"#section-Creating-Processing-Instructions\">Creating Processing\nInstructions</a><br/><a href = \"#section-Creating-Comments\">Creating\nComments</a><br/><a href = \"#copying\">Copying</a><br/><a href = \"#section-Computing-Generated-Text\">Computing Generated Text</a><br/><a href = \"#value-of\">Generating Text with xsl:value-of</a><br/><a href = \"#attribute-value-templates\">Attribute Value Templates</a><br/><a href = \"#number\">Numbering</a><br/><a href = \"#convert\">Number to String Conversion Attributes</a><br/><a href = \"#for-each\">Repetition</a><br/><a href = \"#section-Conditional-Processing\">Conditional Processing</a><br/><a href = \"#section-Conditional-Processing-with-xsl:if\">Conditional Processing\nwith xsl:if</a><br/><a href = \"#section-Conditional-Processing-with-xsl:choose\">Conditional Processing\nwith xsl:choose</a><br/><a href = \"#sorting\">Sorting</a><br/><a href = \"#variables\">Variables and Parameters</a><br/><a href = \"#section-Result-Tree-Fragments\">Result\nTree Fragments</a><br/><a href = \"#variable-values\">Values of Variables\nand Parameters</a><br/><a href = \"#copy-of\">Using Values of Variables and\nParameters with xsl:copy-of</a><br/><a href = \"#top-level-variables\">Top-level\nVariables and Parameters</a><br/><a href = \"#local-variables\">Variables and\nParameters within Templates</a><br/><a href = \"#section-Passing-Parameters-to-Templates\">Passing Parameters to\nTemplates</a><br/><a href = \"#add-func\">Additional Functions</a><br/><a href = \"#document\">Multiple Source\nDocuments</a><br/><a href = \"#key\">Keys</a><br/><a href = \"#format-number\">Number Formatting</a><br/><a href = \"#misc-func\">Miscellaneous Additional\nFunctions</a><br/><a href = \"#message\">Messages</a><br/><a href = \"#extension\">Extensions</a><br/><a href = \"#extension-element\">Extension\nElements</a><br/><a href = \"#section-Extension-Functions\">Extension\nFunctions</a><br/><a href = \"#fallback\">Fallback</a><br/><a href = \"#output\">Output</a><br/><a href = \"#section-XML-Output-Method\">XML Output\nMethod</a><br/><a href = \"#section-HTML-Output-Method\">HTML\nOutput Method</a><br/><a href = \"#section-Text-Output-Method\">Text\nOutput Method</a><br/><a href = \"#disable-output-escaping\">Disabling\nOutput Escaping</a><br/><a href = \"#conformance\">Conformance</a><br/><a href = \"#notation\">Notation</a><br/><h3>Appendices</h3><a href = \"#section-References\">References</a><br/><a href = \"#section-Normative-References\">Normative\nReferences</a><br/><a href = \"#section-Other-References\">Other\nReferences</a><br/><a href = \"#element-syntax-summary\">Element Syntax Summary</a><br/><a href = \"#dtd\">DTD Fragment for XSLT Stylesheets</a><br/><a href = \"#section-Examples\">Examples</a><br/><a href = \"#section-Document-Example\">Document\nExample</a><br/><a href = \"#data-example\">Data Example</a><br/><a href = \"#section-Acknowledgements\">Acknowledgements</a><br/><a href = \"#section-Changes-from-Proposed-Recommendation\">Changes from\nProposed Recommendation</a><br/><a href = \"#section-Features-under-Consideration-for-Future-Versions-of-XSLT\">Features\nunder Consideration for Future Versions of XSLT</a><br/><hr/><h2><a name = \"section-Introduction\" id = \"section-Introduction\"></a>1 Introduction</h2><p>This specification defines the syntax and semantics of the XSLT language. \nA transformation in the XSLT language is expressed as a well-formed XML\ndocument <a href = \"#XML\">[XML]</a> conforming to the Namespaces in XML\nRecommendation <a href = \"#XMLNAMES\">[XML Names]</a>, which may include both\nelements that are defined by XSLT and elements that are not defined by XSLT. \n<a name = \"dt-xslt-namespace\" id = \"dt-xslt-namespace\"></a>XSLT-defined elements are distinguished by\nbelonging to a specific XML namespace (see <a href = \"#xslt-namespace\">[<b>2.1\nXSLT Namespace</b>]</a>), which is referred to in this specification as the\n<b>XSLT namespace</b>. Thus this specification is a definition of the syntax\nand semantics of the XSLT namespace.</p><p>A transformation expressed in XSLT describes rules for transforming a\nsource tree into a result tree.  The transformation is achieved by\nassociating patterns with templates.  A pattern is matched against elements\nin the source tree.  A template is instantiated to create part of the result\ntree.  The result tree is separate from the source tree.  The structure of\nthe result tree can be completely different from the structure of the source\ntree. In constructing the result tree, elements from the source tree can be\nfiltered and reordered, and arbitrary structure can be added.</p><p>A transformation expressed in XSLT is called a stylesheet.  This is\nbecause, in the case when XSLT is transforming into the XSL formatting\nvocabulary, the transformation functions as a stylesheet.</p><p>This document does not specify how an XSLT stylesheet is associated with\nan XML document.  It is recommended that XSL processors support the mechanism\ndescribed in <a href = \"#XMLSTYLE\">[XML Stylesheet]</a>.  When this or any\nother mechanism yields a sequence of more than one XSLT stylesheet to be\napplied simultaneously to a XML document, then the effect should be the same\nas applying a single stylesheet that imports each member of the sequence in\norder (see <a href = \"#import\">[<b>2.6.2 Stylesheet Import</b>]</a>).</p><p>A stylesheet contains a set of template rules.  A template rule has two\nparts: a pattern which is matched against nodes in the source tree and a\ntemplate which can be instantiated to form part of the result tree.  This\nallows a stylesheet to be applicable to a wide class of documents that have\nsimilar source tree structures.</p><p>A template is instantiated for a particular source element to create part\nof the result tree. A template can contain elements that specify literal\nresult element structure.  A template can also contain elements from the XSLT\nnamespace that are instructions for creating result tree fragments.  When a\ntemplate is instantiated, each instruction is executed and replaced by the\nresult tree fragment that it creates. Instructions can select and process\ndescendant source elements.  Processing a descendant element creates a result\ntree fragment by finding the applicable template rule and instantiating its\ntemplate. Note that elements are only processed when they have been selected\nby the execution of an instruction.  The result tree is constructed by\nfinding the template rule for the root node and instantiating its\ntemplate.</p><p>In the process of finding the applicable template rule, more than one\ntemplate rule may have a pattern that matches a given element. However, only\none template rule will be applied. The method for deciding which template\nrule to apply is described in <a href = \"#conflict\">[<b>5.5 Conflict Resolution\nfor Template Rules</b>]</a>.</p><p>A single template by itself has considerable power: it can create\nstructures of arbitrary complexity; it can pull string values out of\narbitrary locations in the source tree; it can generate structures that are\nrepeated according to the occurrence of elements in the source tree.  For\nsimple transformations where the structure of the result tree is independent\nof the structure of the source tree, a stylesheet can often consist of only a\nsingle template, which functions as a template for the complete result tree. \nTransformations on XML documents that represent data are often of this kind\n(see <a href = \"#data-example\">[<b>D.2 Data Example</b>]</a>). XSLT allows a\nsimplified syntax for such stylesheets (see <a href = \"#result-element-stylesheet\">[<b>2.3 Literal Result Element as\nStylesheet</b>]</a>).</p><p>When a template is instantiated, it is always instantiated with respect to\na <a name = \"dt-current-node\" id = \"dt-current-node\"></a><b>current node</b> and a <a name = \"dt-current-node-list\" id = \"dt-current-node-list\"></a><b>current node list</b>. The current node is\nalways a member of the current node list.  Many operations in XSLT are\nrelative to the current node. Only a few instructions change the current node\nlist or the current node (see <a href = \"#rules\">[<b>5 Template Rules</b>]</a>\nand <a href = \"#for-each\">[<b>8 Repetition</b>]</a>); during the instantiation\nof one of these instructions, the current node list changes to a new list of\nnodes and each member of this new list becomes the current node in turn;\nafter the instantiation of the instruction is complete, the current node and\ncurrent node list revert to what they were before the instruction was\ninstantiated.</p><p>XSLT makes use of the expression language defined by <a href = \"#XPATH\">[XPath]</a> for selecting elements for processing, for\nconditional processing and for generating text.</p><p>XSLT provides two \"hooks\" for extending the language, one hook for\nextending the set of instruction elements used in templates and one hook for\nextending the set of functions used in XPath expressions.  These hooks are\nboth based on XML namespaces. This version of XSLT does not define a\nmechanism for implementing the hooks. See <a href = \"#extension\">[<b>14\nExtensions</b>]</a>.</p><blockquote>\n  <b>NOTE:</b>The XSL WG intends to define such a mechanism in a future\n  version of this specification or in a separate specification.</blockquote><p>The element syntax summary notation used to describe the syntax of\nXSLT-defined elements is described in <a href = \"#notation\">[<b>18\nNotation</b>]</a>.</p><p>The MIME media types <code>text/xml</code> and\n<code>application/xml</code> <a href = \"#RFC2376\">[RFC2376]</a> should be used\nfor XSLT stylesheets.  It is possible that a media type will be registered\nspecifically for XSLT stylesheets; if and when it is, that media type may\nalso be used.</p><h2><a name = \"section-Stylesheet-Structure\" id = \"section-Stylesheet-Structure\"></a>2 Stylesheet Structure</h2><h3><a name = \"xslt-namespace\" id = \"xslt-namespace\"></a>2.1 XSLT Namespace</h3><p>The XSLT namespace has the URI\n<code>http://www.w3.org/1999/XSL/Transform</code>.</p><blockquote>\n  <b>NOTE:</b>The <code>1999</code> in the URI indicates the year in which\n  the URI was allocated by the W3C.  It does not indicate the version of XSLT\n  being used, which is specified by attributes (see <a href = \"#stylesheet-element\">[<b>2.2 Stylesheet Element</b>]</a> and <a href = \"#result-element-stylesheet\">[<b>2.3 Literal Result Element as\n  Stylesheet</b>]</a>).</blockquote><p>XSLT processors must use the XML namespaces mechanism <a href = \"#XMLNAMES\">[XML Names]</a> to recognize elements and attributes from\nthis namespace. Elements from the XSLT namespace are recognized only in the\nstylesheet not in the source document. The complete list of XSLT-defined\nelements is specified in <a href = \"#element-syntax-summary\">[<b>B Element\nSyntax Summary</b>]</a>.  Vendors must not extend the XSLT namespace with\nadditional elements or attributes. Instead, any extension must be in a\nseparate namespace.  Any namespace that is used for additional instruction\nelements must be identified by means of the extension element mechanism\nspecified in <a href = \"#extension-element\">[<b>14.1 Extension\nElements</b>]</a>.</p><p>This specification uses a prefix of <code>xsl:</code> for referring to\nelements in the XSLT namespace. However, XSLT stylesheets are free to use any\nprefix, provided that there is a namespace declaration that binds the prefix\nto the URI of the XSLT namespace.</p><p>An element from the XSLT namespace may have any attribute not from the\nXSLT namespace, provided that the <a href = \"http://www.w3.org/TR/xpath#dt-expanded-name\">expanded-name</a> of the\nattribute has a non-null namespace URI.  The presence of such attributes must\nnot change the behavior of XSLT elements and functions defined in this\ndocument. Thus, an XSLT processor is always free to ignore such attributes,\nand must ignore such attributes without giving an error if it does not\nrecognize the namespace URI. Such attributes can provide, for example, unique\nidentifiers, optimization hints, or documentation.</p><p>It is an error for an element from the XSLT namespace to have attributes\nwith expanded-names that have null namespace URIs (i.e. attributes with\nunprefixed names) other than attributes defined for the element in this\ndocument.</p><blockquote>\n  <b>NOTE:</b>The conventions used for the names of XSLT elements, attributes\n  and functions are that names are all lower-case, use hyphens to separate\n  words, and use abbreviations only if they already appear in the syntax of a\n  related language such as XML or HTML.</blockquote><h3><a name = \"stylesheet-element\" id = \"stylesheet-element\"></a>2.2 Stylesheet Element</h3><p class = \"element-syntax\"><a name = \"XSLT_element-stylesheet\" id = \"XSLT_element-stylesheet\"></a><code>&lt;xsl:stylesheet<br/>\n&nbsp;&nbsp;id = <var>id</var> <br/>\n&nbsp;&nbsp;extension-element-prefixes = <var>tokens</var> <br/>\n&nbsp;&nbsp;exclude-result-prefixes = <var>tokens</var> <br/>\n&nbsp;&nbsp;<b>version</b> = <var>number</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: (<a href = \"#XSLT_element-import\">xsl:import</a>*,\n<var>top-level-elements</var>) --&gt;<br/>\n&lt;/xsl:stylesheet&gt;</code></p><p class = \"element-syntax\"><a name = \"XSLT_element-transform\" id = \"XSLT_element-transform\"></a><code>&lt;xsl:transform<br/>\n&nbsp;&nbsp;id = <var>id</var> <br/>\n&nbsp;&nbsp;extension-element-prefixes = <var>tokens</var> <br/>\n&nbsp;&nbsp;exclude-result-prefixes = <var>tokens</var> <br/>\n&nbsp;&nbsp;<b>version</b> = <var>number</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: (<a href = \"#XSLT_element-import\">xsl:import</a>*,\n<var>top-level-elements</var>) --&gt;<br/>\n&lt;/xsl:transform&gt;</code></p><p>A stylesheet is represented by an <code>xsl:stylesheet</code> element in\nan XML document.  <code>xsl:transform</code> is allowed as a synonym for\n<code>xsl:stylesheet</code>.</p><p>An <code>xsl:stylesheet</code> element must have a <code>version</code>\nattribute, indicating the version of XSLT that the stylesheet requires.  For\nthis version of XSLT, the value should be <code>1.0</code>.  When the value\nis not equal to <code>1.0</code>, forwards-compatible processing mode is\nenabled (see <a href = \"#forwards\">[<b>2.5 Forwards-Compatible\nProcessing</b>]</a>).</p><p>The <code>xsl:stylesheet</code> element may contain the following types of\nelements:</p><ul>\n  <li><p><code>xsl:import</code></p>\n  </li>\n  <li><p><code>xsl:include</code></p>\n  </li>\n  <li><p><code>xsl:strip-space</code></p>\n  </li>\n  <li><p><code>xsl:preserve-space</code></p>\n  </li>\n  <li><p><code>xsl:output</code></p>\n  </li>\n  <li><p><code>xsl:key</code></p>\n  </li>\n  <li><p><code>xsl:decimal-format</code></p>\n  </li>\n  <li><p><code>xsl:namespace-alias</code></p>\n  </li>\n  <li><p><code>xsl:attribute-set</code></p>\n  </li>\n  <li><p><code>xsl:variable</code></p>\n  </li>\n  <li><p><code>xsl:param</code></p>\n  </li>\n  <li><p><code>xsl:template</code></p>\n  </li>\n</ul><p><a name = \"dt-top-level\" id = \"dt-top-level\"></a>An element occurring as a child of an\n<code>xsl:stylesheet</code> element is called a <b>top-level</b> element.</p><p>This example shows the structure of a stylesheet.  Ellipses\n(<code>...</code>) indicate where attribute values or content have been\nomitted.  Although this example shows one of each type of allowed element,\nstylesheets may contain zero or more of each of these elements.</p><pre>&lt;xsl:stylesheet version=\"1.0\"\n                xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"&gt;\n  &lt;xsl:import href=\"...\"/&gt;\n\n  &lt;xsl:include href=\"...\"/&gt;\n\n  &lt;xsl:strip-space elements=\"...\"/&gt;\n  \n  &lt;xsl:preserve-space elements=\"...\"/&gt;\n\n  &lt;xsl:output method=\"...\"/&gt;\n\n  &lt;xsl:key name=\"...\" match=\"...\" use=\"...\"/&gt;\n\n  &lt;xsl:decimal-format name=\"...\"/&gt;\n\n  &lt;xsl:namespace-alias stylesheet-prefix=\"...\" result-prefix=\"...\"/&gt;\n\n  &lt;xsl:attribute-set name=\"...\"&gt;\n    ...\n  &lt;/xsl:attribute-set&gt;\n\n  &lt;xsl:variable name=\"...\"&gt;...&lt;/xsl:variable&gt;\n\n  &lt;xsl:param name=\"...\"&gt;...&lt;/xsl:param&gt;\n\n  &lt;xsl:template match=\"...\"&gt;\n    ...\n  &lt;/xsl:template&gt;\n\n  &lt;xsl:template name=\"...\"&gt;\n    ...\n  &lt;/xsl:template&gt;\n\n&lt;/xsl:stylesheet&gt;</pre><p>The order in which the children of the <code>xsl:stylesheet</code> element\noccur is not significant except for <code>xsl:import</code> elements and for\nerror recovery.  Users are free to order the elements as they prefer, and\nstylesheet creation tools need not provide control over the order in which\nthe elements occur.</p><p>In addition, the <code>xsl:stylesheet</code> element may contain any\nelement not from the XSLT namespace, provided that the expanded-name of the\nelement has a non-null namespace URI.  The presence of such top-level\nelements must not change the behavior of XSLT elements and functions defined\nin this document; for example, it would not be permitted for such a top-level\nelement to specify that <code>xsl:apply-templates</code> was to use different\nrules to resolve conflicts. Thus, an XSLT processor is always free to ignore\nsuch top-level elements, and must ignore a top-level element without giving\nan error if it does not recognize the namespace URI. Such elements can\nprovide, for example,</p><ul>\n  <li><p>information used by extension elements or extension functions (see\n    <a href = \"#extension\">[<b>14 Extensions</b>]</a>),</p>\n  </li>\n  <li><p>information about what to do with the result tree,</p>\n  </li>\n  <li><p>information about how to obtain the source tree,</p>\n  </li>\n  <li><p>metadata about the stylesheet,</p>\n  </li>\n  <li><p>structured documentation for the stylesheet.</p>\n  </li>\n</ul><h3><a name = \"result-element-stylesheet\" id = \"result-element-stylesheet\"></a>2.3 Literal Result Element as\nStylesheet</h3><p>A simplified syntax is allowed for stylesheets that consist of only a\nsingle template for the root node.  The stylesheet may consist of just a\nliteral result element (see <a href = \"#literal-result-element\">[<b>7.1.1\nLiteral Result Elements</b>]</a>).  Such a stylesheet is equivalent to a\nstylesheet with an <code>xsl:stylesheet</code> element containing a template\nrule containing the literal result element; the template rule has a match\npattern of <code>/</code>. For example</p><pre>&lt;html xsl:version=\"1.0\"\n      xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n      xmlns=\"http://www.w3.org/TR/xhtml1/strict\"&gt;\n  &lt;head&gt;\n    &lt;title&gt;Expense Report Summary&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Total Amount: &lt;xsl:value-of select=\"expense-report/total\"/&gt;&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</pre><p>has the same meaning as</p><pre>&lt;xsl:stylesheet version=\"1.0\"\n                xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n                xmlns=\"http://www.w3.org/TR/xhtml1/strict\"&gt;\n&lt;xsl:template match=\"/\"&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Expense Report Summary&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Total Amount: &lt;xsl:value-of select=\"expense-report/total\"/&gt;&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n&lt;/xsl:template&gt;\n&lt;/xsl:stylesheet&gt;</pre><p>A literal result element that is the document element of a stylesheet must\nhave an <code>xsl:version</code> attribute, which indicates the version of\nXSLT that the stylesheet requires.  For this version of XSLT, the value\nshould be <code>1.0</code>; the value must be a <a href = \"http://www.w3.org/TR/xpath#NT-Number\">Number</a>.  Other literal result\nelements may also have an <code>xsl:version</code> attribute. When the\n<code>xsl:version</code> attribute is not equal to <code>1.0</code>,\nforwards-compatible processing mode is enabled (see <a href = \"#forwards\">[<b>2.5 Forwards-Compatible Processing</b>]</a>).</p><p>The allowed content of a literal result element when used as a stylesheet\nis no different from when it occurs within a stylesheet. Thus, a literal\nresult element used as a stylesheet cannot contain <a href = \"#dt-top-level\">top-level</a> elements.</p><p>In some situations, the only way that a system can recognize that an XML\ndocument needs to be processed by an XSLT processor as an XSLT stylesheet is\nby examining the XML document itself.  Using the simplified syntax makes this\nharder.</p><blockquote>\n  <b>NOTE:</b>For example, another XML language (AXL) might also use an\n  <code>axl:version</code> on the document element to indicate that an XML\n  document was an AXL document that required processing by an AXL processor;\n  if a document had both an <code>axl:version</code> attribute and an\n  <code>xsl:version</code> attribute, it would be unclear whether the\n  document should be processed by an XSLT processor or an AXL\nprocessor.</blockquote><p>Therefore, the simplified syntax should not be used for XSLT stylesheets\nthat may be used in such a situation.  This situation can, for example, arise\nwhen an XSLT stylesheet is transmitted as a message with a MIME media type of\n<code>text/xml</code> or <code>application/xml</code> to a recipient that\nwill use the MIME media type to determine how the message is processed.</p><h3><a name = \"qname\" id = \"qname\"></a>2.4 Qualified Names</h3><p>The name of an internal XSLT object, specifically a named template (see <a href = \"#named-templates\">[<b>6 Named Templates</b>]</a>), a mode (see <a href = \"#modes\">[<b>5.7 Modes</b>]</a>), an attribute set (see <a href = \"#attribute-sets\">[<b>7.1.4 Named Attribute Sets</b>]</a>), a key (see\n<a href = \"#key\">[<b>12.2 Keys</b>]</a>), a decimal-format (see <a href = \"#format-number\">[<b>12.3 Number Formatting</b>]</a>), a variable or a\nparameter (see <a href = \"#variables\">[<b>11 Variables and Parameters</b>]</a>)\nis specified as a <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a>.  If it has a\nprefix, then the prefix is expanded into a URI reference using the namespace\ndeclarations in effect on the attribute in which the name occurs.  The <a href = \"http://www.w3.org/TR/xpath#dt-expanded-name\">expanded-name</a>\nconsisting of the local part of the name and the possibly null URI reference\nis used as the name of the object.  The default namespace is <i>not</i> used\nfor unprefixed names.</p><h3><a name = \"forwards\" id = \"forwards\"></a>2.5 Forwards-Compatible Processing</h3><p>An element enables forwards-compatible mode for itself, its attributes,\nits descendants and their attributes if either it is an\n<code>xsl:stylesheet</code> element whose <code>version</code> attribute is\nnot equal to <code>1.0</code>, or it is a literal result element that has an\n<code>xsl:version</code> attribute whose value is not equal to\n<code>1.0</code>, or it is a literal result element that does not have an\n<code>xsl:version</code> attribute and that is the document element of a\nstylesheet using the simplified syntax (see <a href = \"#result-element-stylesheet\">[<b>2.3 Literal Result Element as\nStylesheet</b>]</a>).  A literal result element that has an\n<code>xsl:version</code> attribute whose value is equal to <code>1.0</code>\ndisables forwards-compatible mode for itself, its attributes, its descendants\nand their attributes.</p><p>If an element is processed in forwards-compatible mode, then:</p><ul>\n  <li><p>if it is a <a href = \"#dt-top-level\">top-level</a> element and XSLT\n    1.0 does not allow such elements as top-level elements, then the element\n    must be ignored along with its content;</p>\n  </li>\n  <li><p>if it is an element in a template and XSLT 1.0 does not allow such\n    elements to occur in templates, then if the element is not instantiated,\n    an error must not be signaled, and if the element is instantiated, the\n    XSLT must perform fallback for the element as specified in <a href = \"#fallback\">[<b>15 Fallback</b>]</a>;</p>\n  </li>\n  <li><p>if the element has an attribute that XSLT 1.0 does not allow the\n    element to have or if the element has an optional attribute with a value\n    that the XSLT 1.0 does not allow the attribute to have, then the\n    attribute must be ignored.</p>\n  </li>\n</ul><p>Thus, any XSLT 1.0 processor must be able to process the following\nstylesheet without error, although the stylesheet includes elements from the\nXSLT namespace that are not defined in this specification:</p><pre>&lt;xsl:stylesheet version=\"1.1\"\n                xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"&gt;\n  &lt;xsl:template match=\"/\"&gt;\n    &lt;xsl:choose&gt;\n      &lt;xsl:when test=\"system-property('xsl:version') &gt;= 1.1\"&gt;\n        &lt;xsl:exciting-new-1.1-feature/&gt;\n      &lt;/xsl:when&gt;\n      &lt;xsl:otherwise&gt;\n        &lt;html&gt;\n        &lt;head&gt;\n          &lt;title&gt;XSLT 1.1 required&lt;/title&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n          &lt;p&gt;Sorry, this stylesheet requires XSLT 1.1.&lt;/p&gt;\n        &lt;/body&gt;\n        &lt;/html&gt;\n      &lt;/xsl:otherwise&gt;\n    &lt;/xsl:choose&gt;\n  &lt;/xsl:template&gt;\n&lt;/xsl:stylesheet&gt;</pre><blockquote>\n  <b>NOTE:</b>If a stylesheet depends crucially on a top-level element\n  introduced by a version of XSL after 1.0, then the stylesheet can use an\n  <code>xsl:message</code> element with <code>terminate=\"yes\"</code> (see <a href = \"#message\">[<b>13 Messages</b>]</a>) to ensure that XSLT processors\n  implementing earlier versions of XSL will not silently ignore the top-level\n  element. For example,\n  <pre>&lt;xsl:stylesheet version=\"1.5\"\n                xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"&gt;\n\n  &lt;xsl:important-new-1.1-declaration/&gt;\n\n  &lt;xsl:template match=\"/\"&gt;\n    &lt;xsl:choose&gt;\n      &lt;xsl:when test=\"system-property('xsl:version') &amp;lt; 1.1\"&gt;\n        &lt;xsl:message terminate=\"yes\"&gt;\n          &lt;xsl:text&gt;Sorry, this stylesheet requires XSLT 1.1.&lt;/xsl:text&gt;\n        &lt;/xsl:message&gt;\n      &lt;/xsl:when&gt;\n      &lt;xsl:otherwise&gt;\n        ...\n      &lt;/xsl:otherwise&gt;\n    &lt;/xsl:choose&gt;\n  &lt;/xsl:template&gt;\n  ...\n&lt;/xsl:stylesheet&gt;</pre>\n</blockquote><p>If an <a href = \"#dt-expression\">expression</a> occurs in an attribute that\nis processed in forwards-compatible mode, then an XSLT processor must recover\nfrom errors in the expression as follows:</p><ul>\n  <li><p>if the expression does not match the syntax allowed by the XPath\n    grammar, then an error must not be signaled unless the expression is\n    actually evaluated;</p>\n  </li>\n  <li><p>if the expression calls a function with an unprefixed name that is\n    not part of the XSLT library, then an error must not be signaled unless\n    the function is actually called;</p>\n  </li>\n  <li><p>if the expression calls a function with a number of arguments that\n    XSLT does not allow or with arguments of types that XSLT does not allow,\n    then an error must not be signaled unless the function is actually\n    called.</p>\n  </li>\n</ul><h3><a name = \"section-Combining-Stylesheets\" id = \"section-Combining-Stylesheets\"></a>2.6 Combining Stylesheets</h3><p>XSLT provides two mechanisms to combine stylesheets:</p><ul>\n  <li>an inclusion mechanism that allows stylesheets to be combined without\n    changing the semantics of the stylesheets being combined, and</li>\n  <li>an import mechanism that allows stylesheets to override each other.</li>\n</ul><h4><a name = \"include\" id = \"include\"></a>2.6.1 Stylesheet Inclusion</h4><p class = \"element-syntax\"><a name = \"XSLT_element-include\" id = \"XSLT_element-include\"></a><code>&lt;!--\nCategory: top-level-element --&gt;<br/>\n&lt;xsl:include<br/>\n&nbsp;&nbsp;<b>href</b> = <var>uri-reference</var>&nbsp;/&gt;</code></p><p>An XSLT stylesheet may include another XSLT stylesheet using an\n<code>xsl:include</code> element. The <code>xsl:include</code> element has an\n<code>href</code> attribute whose value is a URI reference identifying the\nstylesheet to be included.  A relative URI is resolved relative to the base\nURI of the <code>xsl:include</code> element (see <a href = \"#base-uri\">[<b>3.2\nBase URI</b>]</a>).</p><p>The <code>xsl:include</code> element is only allowed as a <a href = \"#dt-top-level\">top-level</a> element.</p><p>The inclusion works at the XML tree level.  The resource located by the\n<code>href</code> attribute value is parsed as an XML document, and the\nchildren of the <code>xsl:stylesheet</code> element in this document replace\nthe <code>xsl:include</code> element in the including document.  The fact\nthat template rules or definitions are included does not affect the way they\nare processed.</p><p>The included stylesheet may use the simplified syntax described in <a href = \"#result-element-stylesheet\">[<b>2.3 Literal Result Element as\nStylesheet</b>]</a>.  The included stylesheet is treated the same as the\nequivalent <code>xsl:stylesheet</code> element.</p><p>It is an error if a stylesheet directly or indirectly includes itself.</p><blockquote>\n  <b>NOTE:</b>Including a stylesheet multiple times can cause errors because\n  of duplicate definitions.  Such multiple inclusions are less obvious when\n  they are indirect. For example, if stylesheet <var>B</var> includes\n  stylesheet <var>A</var>, stylesheet <var>C</var> includes stylesheet\n  <var>A</var>, and stylesheet <var>D</var> includes both stylesheet\n  <var>B</var> and stylesheet <var>C</var>, then <var>A</var> will be\n  included indirectly by <var>D</var> twice.  If all of <var>B</var>,\n  <var>C</var> and <var>D</var> are used as independent stylesheets, then the\n  error can be avoided by separating everything in <var>B</var> other than\n  the inclusion of <var>A</var> into a separate stylesheet <var>B'</var> and\n  changing <var>B</var> to contain just inclusions of <var>B'</var> and\n  <var>A</var>, similarly for <var>C</var>, and then changing <var>D</var> to\n  include <var>A</var>, <var>B'</var>, <var>C'</var>.</blockquote><h4><a name = \"import\" id = \"import\"></a>2.6.2 Stylesheet Import</h4><p class = \"element-syntax\"><a name = \"XSLT_element-import\" id = \"XSLT_element-import\"></a><code>&lt;xsl:import<br/>\n&nbsp;&nbsp;<b>href</b> = <var>uri-reference</var>&nbsp;/&gt;</code></p><p>An XSLT stylesheet may import another XSLT stylesheet using an\n<code>xsl:import</code> element.  Importing a stylesheet is the same as\nincluding it (see <a href = \"#include\">[<b>2.6.1 Stylesheet Inclusion</b>]</a>)\nexcept that definitions and template rules in the importing stylesheet take\nprecedence over template rules and definitions in the imported stylesheet;\nthis is described in more detail below.  The <code>xsl:import</code> element\nhas an <code>href</code> attribute whose value is a URI reference identifying\nthe stylesheet to be imported.  A relative URI is resolved relative to the\nbase URI of the <code>xsl:import</code> element (see <a href = \"#base-uri\">[<b>3.2 Base URI</b>]</a>).</p><p>The <code>xsl:import</code> element is only allowed as a <a href = \"#dt-top-level\">top-level</a> element.  The <code>xsl:import</code>\nelement children must precede all other element children of an\n<code>xsl:stylesheet</code> element, including any <code>xsl:include</code>\nelement children.  When <code>xsl:include</code> is used to include a\nstylesheet, any <code>xsl:import</code> elements in the included document are\nmoved up in the including document to after any existing\n<code>xsl:import</code> elements in the including document.</p><p>For example,</p><pre>&lt;xsl:stylesheet version=\"1.0\"\n                xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"&gt;\n  &lt;xsl:import href=\"article.xsl\"/&gt;\n  &lt;xsl:import href=\"bigfont.xsl\"/&gt;\n  &lt;xsl:attribute-set name=\"note-style\"&gt;\n    &lt;xsl:attribute name=\"font-style\"&gt;italic&lt;/xsl:attribute&gt;\n  &lt;/xsl:attribute-set&gt;\n&lt;/xsl:stylesheet&gt;</pre><p><a name = \"dt-import-tree\" id = \"dt-import-tree\"></a>The <code>xsl:stylesheet</code> elements\nencountered during processing of a stylesheet that contains\n<code>xsl:import</code> elements are treated as forming an <b>import\ntree</b>.  In the import tree, each <code>xsl:stylesheet</code> element has\none import child for each <code>xsl:import</code> element that it contains.\nAny <code>xsl:include</code> elements are resolved before constructing the\nimport tree. <a name = \"dt-import-precedence\" id = \"dt-import-precedence\"></a>An\n<code>xsl:stylesheet</code> element in the import tree is defined to have\nlower <b>import precedence</b> than another <code>xsl:stylesheet</code>\nelement in the import tree if it would be visited before that\n<code>xsl:stylesheet</code> element in a post-order traversal of the import\ntree (i.e. a traversal of the import tree in which an\n<code>xsl:stylesheet</code> element is visited after its import children).\nEach definition and template rule has import precedence determined by the\n<code>xsl:stylesheet</code> element that contains it.</p><p>For example, suppose</p><ul>\n  <li><p>stylesheet <var>A</var> imports stylesheets <var>B</var> and\n    <var>C</var> in that order;</p>\n  </li>\n  <li><p>stylesheet <var>B</var> imports stylesheet <var>D</var>;</p>\n  </li>\n  <li><p>stylesheet <var>C</var> imports stylesheet <var>E</var>.</p>\n  </li>\n</ul><p>Then the order of import precedence (lowest first) is <var>D</var>,\n<var>B</var>, <var>E</var>, <var>C</var>, <var>A</var>.</p><blockquote>\n  <b>NOTE:</b>Since <code>xsl:import</code> elements are required to occur\n  before any definitions or template rules, an implementation that processes\n  imported stylesheets at the point at which it encounters the\n  <code>xsl:import</code> element will encounter definitions and template\n  rules in increasing order of import precedence.</blockquote><p>In general, a definition or template rule with higher import precedence\ntakes precedence over a definition or template rule with lower import\nprecedence.  This is defined in detail for each kind of definition and for\ntemplate rules.</p><p>It is an error if a stylesheet directly or indirectly imports itself.\nApart from this, the case where a stylesheet with a particular URI is\nimported in multiple places is not treated specially. The <a href = \"#dt-import-tree\">import tree</a> will have a separate\n<code>xsl:stylesheet</code> for each place that it is imported.</p><blockquote>\n  <b>NOTE:</b>If <code>xsl:apply-imports</code> is used (see <a href = \"#apply-imports\">[<b>5.6 Overriding Template Rules</b>]</a>), the\n  behavior may be different from the behavior if the stylesheet had been\n  imported only at the place with the highest <a href = \"#dt-import-precedence\">import precedence</a>.</blockquote><h3><a name = \"section-Embedding-Stylesheets\" id = \"section-Embedding-Stylesheets\"></a>2.7 Embedding Stylesheets</h3><p>Normally an XSLT stylesheet is a complete XML document with the\n<code>xsl:stylesheet</code> element as the document element. However, an XSLT\nstylesheet may also be embedded in another resource. Two forms of embedding\nare possible:</p><ul>\n  <li>the XSLT stylesheet may be textually embedded in a non-XML resource,\n  or</li>\n  <li>the <code>xsl:stylesheet</code> element may occur in an XML document\n    other than as the document element.</li>\n</ul><p>To facilitate the second form of embedding, the\n<code>xsl:stylesheet</code> element is allowed to have an ID attribute that\nspecifies a unique identifier.</p><blockquote>\n  <b>NOTE:</b>In order for such an attribute to be used with the XPath <b><a href = \"http://www.w3.org/TR/xpath#function-id\">id</a></b> function, it must\n  actually be declared in the DTD as being an ID.</blockquote><p>The following example shows how the <code>xml-stylesheet</code> processing\ninstruction <a href = \"#XMLSTYLE\">[XML Stylesheet]</a> can be used to allow a\ndocument to contain its own stylesheet.  The URI reference uses a relative\nURI with a fragment identifier to locate the <code>xsl:stylesheet</code>\nelement:</p><pre>&lt;?xml-stylesheet type=\"text/xml\" href=\"#style1\"?&gt;\n&lt;!DOCTYPE doc SYSTEM \"doc.dtd\"&gt;\n&lt;doc&gt;\n&lt;head&gt;\n&lt;xsl:stylesheet id=\"style1\"\n                version=\"1.0\"\n                xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n                xmlns:fo=\"http://www.w3.org/1999/XSL/Format\"&gt;\n&lt;xsl:import href=\"doc.xsl\"/&gt;\n&lt;xsl:template match=\"id('foo')\"&gt;\n  &lt;fo:block font-weight=\"bold\"&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;\n&lt;/xsl:template&gt;\n&lt;xsl:template match=\"xsl:stylesheet\"&gt;\n  &lt;!-- ignore --&gt;\n&lt;/xsl:template&gt;\n&lt;/xsl:stylesheet&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;para id=\"foo\"&gt;\n...\n&lt;/para&gt;\n&lt;/body&gt;\n&lt;/doc&gt;</pre><blockquote>\n  <b>NOTE:</b>A stylesheet that is embedded in the document to which it is to\n  be applied or that may be included or imported into an stylesheet that is\n  so embedded typically needs to contain a template rule that specifies that\n  <code>xsl:stylesheet</code> elements are to be ignored.</blockquote><h2><a name = \"data-model\" id = \"data-model\"></a>3 Data Model</h2><p>The data model used by XSLT is the same as that used by <a href = \"http://www.w3.org/TR/xpath#data-model\">XPath</a> with the additions\ndescribed in this section.  XSLT operates on source, result and stylesheet\ndocuments using the same data model.  Any two XML documents that have the\nsame tree will be treated the same by XSLT.</p><p>Processing instructions and comments in the stylesheet are ignored: the\nstylesheet is treated as if neither processing instruction nodes nor comment\nnodes were included in the tree that represents the stylesheet.</p><h3><a name = \"root-node-children\" id = \"root-node-children\"></a>3.1 Root Node Children</h3><p>The normal restrictions on the children of the root node are relaxed for\nthe result tree.  The result tree may have any sequence of nodes as children\nthat would be possible for an element node. In particular, it may have text\nnode children, and any number of element node children. When written out\nusing the XML output method (see <a href = \"#output\">[<b>16 Output</b>]</a>),\nit is possible that a result tree will not be a well-formed XML document;\nhowever, it will always be a well-formed external general parsed entity.</p><p>When the source tree is created by parsing a well-formed XML document, the\nroot node of the source tree will automatically satisfy the normal\nrestrictions of having no text node children and exactly one element child. \nWhen the source tree is created in some other way, for example by using the\nDOM, the usual restrictions are relaxed for the source tree as for the result\ntree.</p><h3><a name = \"base-uri\" id = \"base-uri\"></a>3.2 Base URI</h3><p>Every node also has an associated URI called its base URI, which is used\nfor resolving attribute values that represent relative URIs into absolute\nURIs.  If an element or processing instruction occurs in an external entity,\nthe base URI of that element or processing instruction is the URI of the\nexternal entity; otherwise, the base URI is the base URI of the document. \nThe base URI of the document node is the URI of the document entity.  The\nbase URI for a text node, a comment node, an attribute node or a namespace\nnode is the base URI of the parent of the node.</p><h3><a name = \"unparsed-entities\" id = \"unparsed-entities\"></a>3.3 Unparsed Entities</h3><p>The root node has a mapping that gives the URI for each unparsed entity\ndeclared in the document's DTD.  The URI is generated from the system\nidentifier and public identifier specified in the entity declaration. The\nXSLT processor may use the public identifier to generate a URI for the entity\ninstead of the URI specified in the system identifier.  If the XSLT processor\ndoes not use the public identifier to generate the URI, it must use the\nsystem identifier; if the system identifier is a relative URI, it must be\nresolved into an absolute URI using the URI of the resource containing the\nentity declaration as the base URI <a href = \"#RFC2396\">[RFC2396]</a>.</p><h3><a name = \"strip\" id = \"strip\"></a>3.4 Whitespace Stripping</h3><p>After the tree for a source document or stylesheet document has been\nconstructed, but before it is otherwise processed by XSLT, some text nodes\nare stripped.  A text node is never stripped unless it contains only\nwhitespace characters.  Stripping the text node removes the text node from\nthe tree.  The stripping process takes as input a set of element names for\nwhich whitespace must be preserved.  The stripping process is applied to both\nstylesheets and source documents, but the set of whitespace-preserving\nelement names is determined differently for stylesheets and for source\ndocuments.</p><p>A text node is preserved if any of the following apply:</p><ul>\n  <li><p>The element name of the parent of the text node is in the set of\n    whitespace-preserving element names.</p>\n  </li>\n  <li><p>The text node contains at least one non-whitespace character. As in\n    XML, a whitespace character is #x20, #x9, #xD or #xA.</p>\n  </li>\n  <li><p>An ancestor element of the text node has an <code>xml:space</code>\n    attribute with a value of <code>preserve</code>, and no closer ancestor\n    element has <code>xml:space</code> with a value of\n    <code>default</code>.</p>\n  </li>\n</ul><p>Otherwise, the text node is stripped.</p><p>The <code>xml:space</code> attributes are not stripped from the tree.</p><blockquote>\n  <b>NOTE:</b>This implies that if an <code>xml:space</code> attribute is\n  specified on a literal result element, it will be included in the\nresult.</blockquote><p>For stylesheets, the set of whitespace-preserving element names consists\nof just <code>xsl:text</code>.</p><p class = \"element-syntax\"><a name = \"XSLT_element-strip-space\" id = \"XSLT_element-strip-space\"></a><code>&lt;!--\nCategory: top-level-element --&gt;<br/>\n&lt;xsl:strip-space<br/>\n&nbsp;&nbsp;<b>elements</b> = <var>tokens</var>&nbsp;/&gt;</code></p><p class = \"element-syntax\"><a name = \"XSLT_element-preserve-space\" id = \"XSLT_element-preserve-space\"></a><code>&lt;!--\nCategory: top-level-element --&gt;<br/>\n&lt;xsl:preserve-space<br/>\n&nbsp;&nbsp;<b>elements</b> = <var>tokens</var>&nbsp;/&gt;</code></p><p>For source documents, the set of whitespace-preserving element names is\nspecified by <code>xsl:strip-space</code> and <code>xsl:preserve-space</code>\n<a href = \"#dt-top-level\">top-level</a> elements.  These elements each have an\n<code>elements</code> attribute whose value is a whitespace-separated list of\n<a href = \"http://www.w3.org/TR/xpath#NT-NameTest\">NameTest</a>s.  Initially,\nthe set of whitespace-preserving element names contains all element names. If\nan element name matches a <a href = \"http://www.w3.org/TR/xpath#NT-NameTest\">NameTest</a> in an\n<code>xsl:strip-space</code> element, then it is removed from the set of\nwhitespace-preserving element names.  If an element name matches a <a href = \"http://www.w3.org/TR/xpath#NT-NameTest\">NameTest</a> in an\n<code>xsl:preserve-space</code> element, then it is added to the set of\nwhitespace-preserving element names.  An element matches a <a href = \"http://www.w3.org/TR/xpath#NT-NameTest\">NameTest</a> if and only if the\n<a href = \"http://www.w3.org/TR/xpath#NT-NameTest\">NameTest</a> would be true\nfor the element as an <a href = \"http://www.w3.org/TR/xpath#node-tests\">XPath\nnode test</a>.  Conflicts between matches to <code>xsl:strip-space</code> and\n<code>xsl:preserve-space</code> elements are resolved the same way as\nconflicts between template rules (see <a href = \"#conflict\">[<b>5.5 Conflict\nResolution for Template Rules</b>]</a>).  Thus, the applicable match for a\nparticular element name is determined as follows:</p><ul>\n  <li><p>First, any match with lower <a href = \"#dt-import-precedence\">import\n    precedence</a> than another match is ignored.</p>\n  </li>\n  <li><p>Next, any match with a <a href = \"http://www.w3.org/TR/xpath#NT-NameTest\">NameTest</a> that has a\n    lower <a href = \"#dt-default-priority\">default priority</a> than the <a href = \"#dt-default-priority\">default priority</a> of the <a href = \"http://www.w3.org/TR/xpath#NT-NameTest\">NameTest</a> of another\n    match is ignored.</p>\n  </li>\n</ul><p>It is an error if this leaves more than one match.  An XSLT processor may\nsignal the error; if it does not signal the error, it must recover by\nchoosing, from amongst the matches that are left, the one that occurs last in\nthe stylesheet.</p><h2><a name = \"section-Expressions\" id = \"section-Expressions\"></a>4 Expressions</h2><p>XSLT uses the expression language defined by XPath <a href = \"#XPATH\">[XPath]</a>.  Expressions are used in XSLT for a variety of\npurposes including:</p><ul>\n  <li>selecting nodes for processing;</li>\n  <li>specifying conditions for different ways of processing a node;</li>\n  <li>generating text to be inserted in the result tree.</li>\n</ul><p><a name = \"dt-expression\" id = \"dt-expression\"></a>An <b>expression</b> must match the XPath\nproduction <a href = \"http://www.w3.org/TR/xpath#NT-Expr\">Expr</a>.</p><p>Expressions occur as the value of certain attributes on XSLT-defined\nelements and within curly braces in <a href = \"#dt-attribute-value-template\">attribute value template</a>s.</p><p>In XSLT, an outermost expression (i.e. an expression that is not part of\nanother expression) gets its context as follows:</p><ul>\n  <li><p>the context node comes from the <a href = \"#dt-current-node\">current\n    node</a></p>\n  </li>\n  <li><p>the context position comes from the position of the <a href = \"#dt-current-node\">current node</a> in the <a href = \"#dt-current-node-list\">current node list</a>; the first position is\n    1</p>\n  </li>\n  <li><p>the context size comes from the size of the <a href = \"#dt-current-node-list\">current node list</a></p>\n  </li>\n  <li><p>the variable bindings are the bindings in scope on the element which\n    has the attribute in which the expression occurs (see <a href = \"#variables\">[<b>11 Variables and Parameters</b>]</a>)</p>\n  </li>\n  <li><p>the set of namespace declarations are those in scope on the element\n    which has the attribute in which the expression occurs; this includes the\n    implicit declaration of the prefix <code>xml</code> required by the the\n    XML Namespaces Recommendation <a href = \"#XMLNAMES\">[XML Names]</a>; the\n    default namespace (as declared by <code>xmlns</code>) is not part of this\n    set</p>\n  </li>\n  <li><p>the function library consists of the core function library together\n    with the additional functions defined in <a href = \"#add-func\">[<b>12\n    Additional Functions</b>]</a> and extension functions as described in <a href = \"#extension\">[<b>14 Extensions</b>]</a>; it is an error for an\n    expression to include a call to any other function</p>\n  </li>\n</ul><h2><a name = \"rules\" id = \"rules\"></a>5 Template Rules</h2><h3><a name = \"section-Processing-Model\" id = \"section-Processing-Model\"></a>5.1 Processing Model</h3><p>A list of source nodes is processed to create a result tree fragment.  The\nresult tree is constructed by processing a list containing just the root\nnode.  A list of source nodes is processed by appending the result tree\nstructure created by processing each of the members of the list in order.  A\nnode is processed by finding all the template rules with patterns that match\nthe node, and choosing the best amongst them; the chosen rule's template is\nthen instantiated with the node as the <a href = \"#dt-current-node\">current\nnode</a> and with the list of source nodes as the <a href = \"#dt-current-node-list\">current node list</a>.  A template typically\ncontains instructions that select an additional list of source nodes for\nprocessing.  The process of matching, instantiation and selection is\ncontinued recursively until no new source nodes are selected for\nprocessing.</p><p>Implementations are free to process the source document in any way that\nproduces the same result as if it were processed using this processing\nmodel.</p><h3><a name = \"patterns\" id = \"patterns\"></a>5.2 Patterns</h3><p><a name = \"dt-pattern\" id = \"dt-pattern\"></a>Template rules identify the nodes to which they\napply by using a <b>pattern</b>.  As well as being used in template rules,\npatterns are used for numbering (see <a href = \"#number\">[<b>7.7\nNumbering</b>]</a>) and for declaring keys (see <a href = \"#key\">[<b>12.2\nKeys</b>]</a>).  A pattern specifies a set of conditions on a node.  A node\nthat satisfies the conditions matches the pattern; a node that does not\nsatisfy the conditions does not match the pattern.  The syntax for patterns\nis a subset of the syntax for expressions. In particular, location paths that\nmeet certain restrictions can be used as patterns.  An expression that is\nalso a pattern always evaluates to an object of type node-set.  A node\nmatches a pattern if the node is a member of the result of evaluating the\npattern as an expression with respect to some possible context; the possible\ncontexts are those whose context node is the node being matched or one of its\nancestors.</p><p>Here are some examples of patterns:</p><ul>\n  <li><p><code>para</code> matches any <code>para</code> element</p>\n  </li>\n  <li><p><code>*</code> matches any element</p>\n  </li>\n  <li><p><code>chapter|appendix</code> matches any <code>chapter</code>\n    element and any <code>appendix</code> element</p>\n  </li>\n  <li><p><code>olist/item</code> matches any <code>item</code> element with\n    an <code>olist</code> parent</p>\n  </li>\n  <li><p><code>appendix//para</code> matches any <code>para</code> element\n    with an <code>appendix</code> ancestor element</p>\n  </li>\n  <li><p><code>/</code> matches the root node</p>\n  </li>\n  <li><p><code>text()</code> matches any text node</p>\n  </li>\n  <li><p><code>processing-instruction()</code> matches any processing\n    instruction</p>\n  </li>\n  <li><p><code>node()</code> matches any node other than an attribute node\n    and the root node</p>\n  </li>\n  <li><p><code>id(\"W11\")</code> matches the element with unique ID\n    <code>W11</code></p>\n  </li>\n  <li><p><code>para[1]</code> matches any <code>para</code> element that is\n    the first <code>para</code> child element of its parent</p>\n  </li>\n  <li><p><code>*[position()=1 and self::para]</code> matches any\n    <code>para</code> element that is the first child element of its\n    parent</p>\n  </li>\n  <li><p><code>para[last()=1]</code> matches any <code>para</code> element\n    that is the only <code>para</code> child element of its parent</p>\n  </li>\n  <li><p><code>items/item[position()&gt;1]</code> matches any\n    <code>item</code> element that has a <code>items</code> parent and that\n    is not the first <code>item</code> child of its parent</p>\n  </li>\n  <li><p><code>item[position() mod 2 = 1]</code> would be true for any\n    <code>item</code> element that is an odd-numbered <code>item</code> child\n    of its parent.</p>\n  </li>\n  <li><p><code>div[@class=\"appendix\"]//p</code> matches any <code>p</code>\n    element with a <code>div</code> ancestor element that has a\n    <code>class</code> attribute with value <code>appendix</code></p>\n  </li>\n  <li><p><code>@class</code> matches any <code>class</code> attribute\n    (<i>not</i> any element that has a <code>class</code> attribute)</p>\n  </li>\n  <li><p><code>@*</code> matches any attribute</p>\n  </li>\n</ul><p>A pattern must match the grammar for <a href = \"#NT-Pattern\">Pattern</a>.  A\n<a href = \"#NT-Pattern\">Pattern</a> is a set of location path patterns\nseparated by <code>|</code>.  A location path pattern is a location path\nwhose steps all use only the <code>child</code> or <code>attribute</code>\naxes.  Although patterns must not use the <code>descendant-or-self</code>\naxis, patterns may use the <code>//</code> operator as well as the\n<code>/</code> operator.  Location path patterns can also start with an <b><a href = \"http://www.w3.org/TR/xpath#function-id\">id</a></b> or <b><a href = \"#function-key\">key</a></b> function call with a literal argument. \nPredicates in a pattern can use arbitrary expressions just like predicates in\na location path.</p><h5>Patterns</h5><table class = \"scrap\">\n  <tbody>\n    <tr valign = \"baseline\">\n      <td><a name = \"NT-Pattern\" id = \"NT-Pattern\"></a>[1]&nbsp;&nbsp;&nbsp;</td>\n      <td>Pattern</td>\n      <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>\n      <td><a href = \"#NT-LocationPathPattern\">LocationPathPattern</a></td>\n      <td></td>\n    </tr>\n    <tr valign = \"baseline\">\n      <td></td>\n      <td></td>\n      <td></td>\n      <td>| <a href = \"#NT-Pattern\">Pattern</a> '|' <a href = \"#NT-LocationPathPattern\">LocationPathPattern</a></td>\n      <td></td>\n    </tr>\n    <tr valign = \"baseline\">\n      <td><a name = \"NT-LocationPathPattern\" id = \"NT-LocationPathPattern\"></a>[2]&nbsp;&nbsp;&nbsp;</td>\n      <td>LocationPathPattern</td>\n      <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>\n      <td>'/' <a href = \"#NT-RelativePathPattern\">RelativePathPattern</a>?</td>\n      <td></td>\n    </tr>\n    <tr valign = \"baseline\">\n      <td></td>\n      <td></td>\n      <td></td>\n      <td>| <a href = \"#NT-IdKeyPattern\">IdKeyPattern</a> (('/' | '//') <a href = \"#NT-RelativePathPattern\">RelativePathPattern</a>)?</td>\n      <td></td>\n    </tr>\n    <tr valign = \"baseline\">\n      <td></td>\n      <td></td>\n      <td></td>\n      <td>| '//'? <a href = \"#NT-RelativePathPattern\">RelativePathPattern</a></td>\n      <td></td>\n    </tr>\n    <tr valign = \"baseline\">\n      <td><a name = \"NT-IdKeyPattern\" id = \"NT-IdKeyPattern\"></a>[3]&nbsp;&nbsp;&nbsp;</td>\n      <td>IdKeyPattern</td>\n      <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>\n      <td>'id' '(' <a href = \"http://www.w3.org/TR/xpath#NT-Literal\">Literal</a> ')'</td>\n      <td></td>\n    </tr>\n    <tr valign = \"baseline\">\n      <td></td>\n      <td></td>\n      <td></td>\n      <td>| 'key' '(' <a href = \"http://www.w3.org/TR/xpath#NT-Literal\">Literal</a> ',' <a href = \"http://www.w3.org/TR/xpath#NT-Literal\">Literal</a> ')'</td>\n      <td></td>\n    </tr>\n    <tr valign = \"baseline\">\n      <td><a name = \"NT-RelativePathPattern\" id = \"NT-RelativePathPattern\"></a>[4]&nbsp;&nbsp;&nbsp;</td>\n      <td>RelativePathPattern</td>\n      <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>\n      <td><a href = \"#NT-StepPattern\">StepPattern</a></td>\n      <td></td>\n    </tr>\n    <tr valign = \"baseline\">\n      <td></td>\n      <td></td>\n      <td></td>\n      <td>| <a href = \"#NT-RelativePathPattern\">RelativePathPattern</a> '/' <a href = \"#NT-StepPattern\">StepPattern</a></td>\n      <td></td>\n    </tr>\n    <tr valign = \"baseline\">\n      <td></td>\n      <td></td>\n      <td></td>\n      <td>| <a href = \"#NT-RelativePathPattern\">RelativePathPattern</a> '//' <a href = \"#NT-StepPattern\">StepPattern</a></td>\n      <td></td>\n    </tr>\n    <tr valign = \"baseline\">\n      <td><a name = \"NT-StepPattern\" id = \"NT-StepPattern\"></a>[5]&nbsp;&nbsp;&nbsp;</td>\n      <td>StepPattern</td>\n      <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>\n      <td><a href = \"#NT-ChildOrAttributeAxisSpecifier\">ChildOrAttributeAxisSpecifier</a>\n        <a href = \"http://www.w3.org/TR/xpath#NT-NodeTest\">NodeTest</a> <a href = \"http://www.w3.org/TR/xpath#NT-Predicate\">Predicate</a>*</td>\n      <td></td>\n    </tr>\n    <tr valign = \"baseline\">\n      <td><a name = \"NT-ChildOrAttributeAxisSpecifier\" id = \"NT-ChildOrAttributeAxisSpecifier\"></a>[6]&nbsp;&nbsp;&nbsp;</td>\n      <td>ChildOrAttributeAxisSpecifier</td>\n      <td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>\n      <td><a href = \"http://www.w3.org/TR/xpath#NT-AbbreviatedAxisSpecifier\">AbbreviatedAxisSpecifier</a></td>\n      <td></td>\n    </tr>\n    <tr valign = \"baseline\">\n      <td></td>\n      <td></td>\n      <td></td>\n      <td>| ('child' | 'attribute') '::'</td>\n      <td></td>\n    </tr>\n  </tbody>\n</table><p>A pattern is defined to match a node if and only if there is possible\ncontext such that when the pattern is evaluated as an expression with that\ncontext, the node is a member of the resulting node-set.  When a node is\nbeing matched, the possible contexts have a context node that is the node\nbeing matched or any ancestor of that node, and a context node list\ncontaining just the context node.</p><p>For example, <code>p</code> matches any <code>p</code> element, because\nfor any <code>p</code> if the expression <code>p</code> is evaluated with the\nparent of the <code>p</code> element as context the resulting node-set will\ncontain that <code>p</code> element as one of its members.</p><blockquote>\n  <b>NOTE:</b>This matches even a <code>p</code> element that is the document\n  element, since the document root is the parent of the document\nelement.</blockquote><p>Although the semantics of patterns are specified indirectly in terms of\nexpression evaluation, it is easy to understand the meaning of a pattern\ndirectly without thinking in terms of expression evaluation.  In a pattern,\n<code>|</code> indicates alternatives; a pattern with one or more\n<code>|</code> separated alternatives matches if any one of the alternative\nmatches.  A pattern that consists of a sequence of <a href = \"#NT-StepPattern\">StepPattern</a>s separated by <code>/</code> or\n<code>//</code> is matched from right to left.  The pattern only matches if\nthe rightmost <a href = \"#NT-StepPattern\">StepPattern</a> matches and a\nsuitable element matches the rest of the pattern; if the separator is\n<code>/</code> then only the parent is a suitable element; if the separator\nis <code>//</code>, then any ancestor is a suitable element.  A <a href = \"#NT-StepPattern\">StepPattern</a> that uses the child axis matches if\nthe <a href = \"http://www.w3.org/TR/xpath#NT-NodeTest\">NodeTest</a> is true for\nthe node and the node is not an attribute node.  A <a href = \"#NT-StepPattern\">StepPattern</a> that uses the attribute axis matches\nif the <a href = \"http://www.w3.org/TR/xpath#NT-NodeTest\">NodeTest</a> is true\nfor the node and the node is an attribute node.  When <code>[]</code> is\npresent, then the first <a href = \"http://www.w3.org/TR/xpath#NT-PredicateExpr\">PredicateExpr</a> in a <a href = \"#NT-StepPattern\">StepPattern</a> is evaluated with the node being\nmatched as the context node and the siblings of the context node that match\nthe <a href = \"http://www.w3.org/TR/xpath#NT-NodeTest\">NodeTest</a> as the\ncontext node list, unless the node being matched is an attribute node, in\nwhich case the context node list is all the attributes that have the same\nparent as the attribute being matched and that match the <a href = \"http://www.w3.org/TR/xpath#NT-NameTest\">NameTest</a>.</p><p>For example</p><pre>appendix//ulist/item[position()=1]</pre><p>matches a node if and only if all of the following are true:</p><ul>\n  <li><p>the <a href = \"http://www.w3.org/TR/xpath#NT-NodeTest\">NodeTest</a>\n    <code>item</code> is true for the node and the node is not an attribute;\n    in other words the node is an <code>item</code> element</p>\n  </li>\n  <li><p>evaluating the <a href = \"http://www.w3.org/TR/xpath#NT-PredicateExpr\">PredicateExpr</a>\n    <code>position()=1</code> with the node as context node and the siblings\n    of the node that are <code>item</code> elements as the context node list\n    yields true</p>\n  </li>\n  <li><p>the node has a parent that matches <code>appendix//ulist</code>;\n    this will be true if the parent is a <code>ulist</code> element that has\n    an <code>appendix</code> ancestor element.</p>\n  </li>\n</ul><h3><a name = \"section-Defining-Template-Rules\" id = \"section-Defining-Template-Rules\"></a>5.3 Defining Template\nRules</h3><p class = \"element-syntax\"><a name = \"XSLT_element-template\" id = \"XSLT_element-template\"></a><code>&lt;!--\nCategory: top-level-element --&gt;<br/>\n&lt;xsl:template<br/>\n&nbsp;&nbsp;match = <var>pattern</var> <br/>\n&nbsp;&nbsp;name = <var>qname</var> <br/>\n&nbsp;&nbsp;priority = <var>number</var> <br/>\n&nbsp;&nbsp;mode = <var>qname</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: (<a href = \"#XSLT_element-param\">xsl:param</a>*,\n<var>template</var>) --&gt;<br/>\n&lt;/xsl:template&gt;</code></p><p>A template rule is specified with the <code>xsl:template</code> element.\nThe <code>match</code> attribute is a <a href = \"#NT-Pattern\">Pattern</a> that\nidentifies the source node or nodes to which the rule applies.  The\n<code>match</code> attribute is required unless the <code>xsl:template</code>\nelement has a <code>name</code> attribute (see <a href = \"#named-templates\">[<b>6 Named Templates</b>]</a>). It is an error for\nthe value of the <code>match</code> attribute to contain a <a href = \"http://www.w3.org/TR/xpath#NT-VariableReference\">VariableReference</a>.\nThe content of the <code>xsl:template</code> element is the template that is\ninstantiated when the template rule is applied.</p><p>For example, an XML document might contain:</p><pre>This is an &lt;emph&gt;important&lt;/emph&gt; point.</pre><p>The following template rule matches <code>emph</code> elements and\nproduces a <code>fo:inline-sequence</code> formatting object with a\n<code>font-weight</code> property of <code>bold</code>.</p><pre>&lt;xsl:template match=\"emph\"&gt;\n  &lt;fo:inline-sequence font-weight=\"bold\"&gt;\n    &lt;xsl:apply-templates/&gt;\n  &lt;/fo:inline-sequence&gt;\n&lt;/xsl:template&gt;</pre><blockquote>\n  <b>NOTE:</b>Examples in this document use the <code>fo:</code> prefix for\n  the namespace <code>http://www.w3.org/1999/XSL/Format</code>, which is the\n  namespace of the formatting objects defined in <a href = \"#XSL\">[XSL]</a>.</blockquote><p>As described next, the <code>xsl:apply-templates</code> element\nrecursively processes the children of the source element.</p><h3><a name = \"section-Applying-Template-Rules\" id = \"section-Applying-Template-Rules\"></a>5.4 Applying Template\nRules</h3><p class = \"element-syntax\"><a name = \"XSLT_element-apply-templates\" id = \"XSLT_element-apply-templates\"></a><code>&lt;!--\nCategory: instruction --&gt;<br/>\n&lt;xsl:apply-templates<br/>\n&nbsp;&nbsp;select = <var>node-set-expression</var> <br/>\n&nbsp;&nbsp;mode = <var>qname</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: (<a href = \"#XSLT_element-sort\">xsl:sort</a> | <a href = \"#XSLT_element-with-param\">xsl:with-param</a>)* --&gt;<br/>\n&lt;/xsl:apply-templates&gt;</code></p><p>This example creates a block for a <code>chapter</code> element and then\nprocesses its immediate children.</p><pre>&lt;xsl:template match=\"chapter\"&gt;\n  &lt;fo:block&gt;\n    &lt;xsl:apply-templates/&gt;\n  &lt;/fo:block&gt;\n&lt;/xsl:template&gt;</pre><p>In the absence of a <code>select</code> attribute, the\n<code>xsl:apply-templates</code> instruction processes all of the children of\nthe current node, including text nodes.  However, text nodes that have been\nstripped as specified in <a href = \"#strip\">[<b>3.4 Whitespace\nStripping</b>]</a> will not be processed.  If stripping of whitespace nodes\nhas not been enabled for an element, then all whitespace in the content of\nthe element will be processed as text, and thus whitespace between child\nelements will count in determining the position of a child element as\nreturned by the <b><a href = \"http://www.w3.org/TR/xpath#function-position\">position</a></b>\nfunction.</p><p>A <code>select</code> attribute can be used to process nodes selected by\nan expression instead of processing all children.  The value of the\n<code>select</code> attribute is an <a href = \"#dt-expression\">expression</a>. \nThe expression must evaluate to a node-set.  The selected set of nodes is\nprocessed in document order, unless a sorting specification is present (see\n<a href = \"#sorting\">[<b>10 Sorting</b>]</a>).  The following example processes\nall of the <code>author</code> children of the <code>author-group</code>:</p><pre>&lt;xsl:template match=\"author-group\"&gt;\n  &lt;fo:inline-sequence&gt;\n    &lt;xsl:apply-templates select=\"author\"/&gt;\n  &lt;/fo:inline-sequence&gt;\n&lt;/xsl:template&gt;</pre><p>The following example processes all of the <code>given-name</code>s of the\n<code>author</code>s that are children of <code>author-group</code>:</p><pre>&lt;xsl:template match=\"author-group\"&gt;\n  &lt;fo:inline-sequence&gt;\n    &lt;xsl:apply-templates select=\"author/given-name\"/&gt;\n  &lt;/fo:inline-sequence&gt;\n&lt;/xsl:template&gt;</pre><p>This example processes all of the <code>heading</code> descendant elements\nof the <code>book</code> element.</p><pre>&lt;xsl:template match=\"book\"&gt;\n  &lt;fo:block&gt;\n    &lt;xsl:apply-templates select=\".//heading\"/&gt;\n  &lt;/fo:block&gt;\n&lt;/xsl:template&gt;</pre><p>It is also possible to process elements that are not descendants of the\ncurrent node.  This example assumes that a <code>department</code> element\nhas <code>group</code> children and <code>employee</code> descendants. It\nfinds an employee's department and then processes the <code>group</code>\nchildren of the <code>department</code>.</p><pre>&lt;xsl:template match=\"employee\"&gt;\n  &lt;fo:block&gt;\n    Employee &lt;xsl:apply-templates select=\"name\"/&gt; belongs to group\n    &lt;xsl:apply-templates select=\"ancestor::department/group\"/&gt;\n  &lt;/fo:block&gt;\n&lt;/xsl:template&gt;</pre><p>Multiple <code>xsl:apply-templates</code> elements can be used within a\nsingle template to do simple reordering.  The following example creates two\nHTML tables. The first table is filled with domestic sales while the second\ntable is filled with foreign sales.</p><pre>&lt;xsl:template match=\"product\"&gt;\n  &lt;table&gt;\n    &lt;xsl:apply-templates select=\"sales/domestic\"/&gt;\n  &lt;/table&gt;\n  &lt;table&gt;\n    &lt;xsl:apply-templates select=\"sales/foreign\"/&gt;\n  &lt;/table&gt;\n&lt;/xsl:template&gt;</pre><blockquote>\n  <b>NOTE:</b> It is possible for there to be two matching descendants where\n  one is a descendant of the other.  This case is not treated specially: both\n  descendants will be processed as usual. For example, given a source document\n  <pre>&lt;doc&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/doc&gt;</pre>\n  the rule\n  <pre>&lt;xsl:template match=\"doc\"&gt;\n  &lt;xsl:apply-templates select=\".//div\"/&gt;\n&lt;/xsl:template&gt;</pre>\n  will process both the outer <code>div</code> and inner <code>div</code>\n  elements.</blockquote><blockquote>\n  <b>NOTE:</b>Typically, <code>xsl:apply-templates</code> is used to process\n  only nodes that are descendants of the current node.  Such use of\n  <code>xsl:apply-templates</code> cannot result in non-terminating\n  processing loops.  However, when <code>xsl:apply-templates</code> is used\n  to process elements that are not descendants of the current node, the\n  possibility arises of non-terminating loops. For example,\n  <pre style = \"color: red\">&lt;xsl:template match=\"foo\"&gt;\n  &lt;xsl:apply-templates select=\".\"/&gt;\n&lt;/xsl:template&gt;</pre>\n  Implementations may be able to detect such loops in some cases, but the\n  possibility exists that a stylesheet may enter a non-terminating loop that\n  an implementation is unable to detect. This may present a denial of service\n  security risk.</blockquote><h3><a name = \"conflict\" id = \"conflict\"></a>5.5 Conflict Resolution for Template Rules</h3><p>It is possible for a source node to match more than one template rule. The\ntemplate rule to be used is determined as follows:</p><ol>\n  <li><p>First, all matching template rules that have lower <a href = \"#dt-import-precedence\">import precedence</a> than the matching\n    template rule or rules with the highest import precedence are eliminated\n    from consideration.</p>\n  </li>\n  <li><p>Next, all matching template rules that have lower priority than the\n    matching template rule or rules with the highest priority are eliminated\n    from consideration.  The priority of a template rule is specified by the\n    <code>priority</code> attribute on the template rule. The value of this\n    must be a real number (positive or negative), matching the production <a href = \"http://www.w3.org/TR/xpath#NT-Number\">Number</a> with an optional\n    leading minus sign (<code>-</code>).  <a name = \"dt-default-priority\" id = \"dt-default-priority\"></a>The <b>default priority</b> is computed as\n    follows:</p>\n    <ul>\n      <li><p>If the pattern contains multiple alternatives separated by\n        <code>|</code>, then it is treated equivalently to a set of template\n        rules, one for each alternative.</p>\n      </li>\n      <li><p>If the pattern has the form of a <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a> preceded\n        by a <a href = \"#NT-ChildOrAttributeAxisSpecifier\">ChildOrAttributeAxisSpecifier</a>\n        or has the form <code>processing-instruction(</code><a href = \"http://www.w3.org/TR/xpath#NT-Literal\">Literal</a><code>)</code>\n        preceded by a <a href = \"#NT-ChildOrAttributeAxisSpecifier\">ChildOrAttributeAxisSpecifier</a>,\n        then the priority is 0.</p>\n      </li>\n      <li><p>If the pattern has the form <a href = \"http://www.w3.org/TR/REC-xml-names#NT-NCName\">NCName</a><code>:*</code>\n        preceded by a <a href = \"#NT-ChildOrAttributeAxisSpecifier\">ChildOrAttributeAxisSpecifier</a>,\n        then the priority is -0.25.</p>\n      </li>\n      <li><p>Otherwise, if the pattern consists of just a <a href = \"http://www.w3.org/TR/xpath#NT-NodeTest\">NodeTest</a> preceded\n        by a <a href = \"#NT-ChildOrAttributeAxisSpecifier\">ChildOrAttributeAxisSpecifier</a>,\n        then the priority is -0.5.</p>\n      </li>\n      <li><p>Otherwise, the priority is 0.5.</p>\n      </li>\n    </ul>\n    <p>Thus, the most common kind of pattern (a pattern that tests for a node\n    with a particular type and a particular expanded-name) has priority 0.\n    The next less specific kind of pattern (a pattern that tests for a node\n    with a particular type and an expanded-name with a particular namespace\n    URI) has priority -0.25.  Patterns less specific than this (patterns that\n    just tests for nodes with particular types) have priority -0.5.  Patterns\n    more specific than the most common kind of pattern have priority 0.5.</p>\n  </li>\n</ol><p>It is an error if this leaves more than one matching template rule.  An\nXSLT processor may signal the error; if it does not signal the error, it must\nrecover by choosing, from amongst the matching template rules that are left,\nthe one that occurs last in the stylesheet.</p><h3><a name = \"apply-imports\" id = \"apply-imports\"></a>5.6 Overriding Template Rules</h3><p class = \"element-syntax\"><a name = \"XSLT_element-apply-imports\" id = \"XSLT_element-apply-imports\"></a><code>&lt;!--\nCategory: instruction --&gt;<br/>\n&lt;xsl:apply-imports&nbsp;/&gt;</code></p><p>A template rule that is being used to override a template rule in an\nimported stylesheet (see <a href = \"#conflict\">[<b>5.5 Conflict Resolution for\nTemplate Rules</b>]</a>) can use the <code>xsl:apply-imports</code> element\nto invoke the overridden template rule.</p><p><a name = \"dt-current-template-rule\" id = \"dt-current-template-rule\"></a>At any point in the processing of a\nstylesheet, there is a <b>current template rule</b>.  Whenever a template\nrule is chosen by matching a pattern, the template rule becomes the current\ntemplate rule for the instantiation of the rule's template. When an\n<code>xsl:for-each</code> element is instantiated, the current template rule\nbecomes null for the instantiation of the content of the\n<code>xsl:for-each</code> element.</p><p><code>xsl:apply-imports</code> processes the current node using only\ntemplate rules that were imported into the stylesheet element containing the\ncurrent template rule; the node is processed in the current template rule's\nmode.  It is an error if <code>xsl:apply-imports</code> is instantiated when\nthe current template rule is null.</p><p>For example, suppose the stylesheet <code>doc.xsl</code> contains a\ntemplate rule for <code>example</code> elements:</p><pre>&lt;xsl:template match=\"example\"&gt;\n  &lt;pre&gt;&lt;xsl:apply-templates/&gt;&lt;/pre&gt;\n&lt;/xsl:template&gt;</pre><p>Another stylesheet could import <code>doc.xsl</code> and modify the\ntreatment of <code>example</code> elements as follows:</p><pre>&lt;xsl:import href=\"doc.xsl\"/&gt;\n\n&lt;xsl:template match=\"example\"&gt;\n  &lt;div style=\"border: solid red\"&gt;\n     &lt;xsl:apply-imports/&gt;\n  &lt;/div&gt;\n&lt;/xsl:template&gt;</pre><p>The combined effect would be to transform an <code>example</code> into an\nelement of the form:</p><pre>&lt;div style=\"border: solid red\"&gt;&lt;pre&gt;...&lt;/pre&gt;&lt;/div&gt;</pre><h3><a name = \"modes\" id = \"modes\"></a>5.7 Modes</h3><p>Modes allow an element to be processed multiple times, each time producing\na different result.</p><p>Both <code>xsl:template</code> and <code>xsl:apply-templates</code> have\nan optional <code>mode</code> attribute.  The value of the <code>mode</code>\nattribute is a <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a>, which is\nexpanded as described in <a href = \"#qname\">[<b>2.4 Qualified Names</b>]</a>.\nIf <code>xsl:template</code> does not have a <code>match</code> attribute, it\nmust not have a <code>mode</code> attribute.  If an\n<code>xsl:apply-templates</code> element has a <code>mode</code> attribute,\nthen it applies only to those template rules from <code>xsl:template</code>\nelements that have a <code>mode</code> attribute with the same value; if an\n<code>xsl:apply-templates</code> element does not have a <code>mode</code>\nattribute, then it applies only to those template rules from\n<code>xsl:template</code> elements that do not have a <code>mode</code>\nattribute.</p><h3><a name = \"built-in-rule\" id = \"built-in-rule\"></a>5.8 Built-in Template Rules</h3><p>There is a built-in template rule to allow recursive processing to\ncontinue in the absence of a successful pattern match by an explicit template\nrule in the stylesheet.  This template rule applies to both element nodes and\nthe root node.  The following shows the equivalent of the built-in template\nrule:</p><pre>&lt;xsl:template match=\"*|/\"&gt;\n  &lt;xsl:apply-templates/&gt;\n&lt;/xsl:template&gt;</pre><p>There is also a built-in template rule for each mode, which allows\nrecursive processing to continue in the same mode in the absence of a\nsuccessful pattern match by an explicit template rule in the stylesheet. \nThis template rule applies to both element nodes and the root node.  The\nfollowing shows the equivalent of the built-in template rule for mode\n<code><var>m</var></code>.</p><pre>&lt;xsl:template match=\"*|/\" mode=\"<var>m</var>\"&gt;\n  &lt;xsl:apply-templates mode=\"<var>m</var>\"/&gt;\n&lt;/xsl:template&gt;</pre><p>There is also a built-in template rule for text and attribute nodes that\ncopies text through:</p><pre>&lt;xsl:template match=\"text()|@*\"&gt;\n  &lt;xsl:value-of select=\".\"/&gt;\n&lt;/xsl:template&gt;</pre><p>The built-in template rule for processing instructions and comments is to\ndo nothing.</p><pre>&lt;xsl:template match=\"processing-instruction()|comment()\"/&gt;</pre><p>The built-in template rule for namespace nodes is also to do nothing.\nThere is no pattern that can match a namespace node; so, the built-in\ntemplate rule is the only template rule that is applied for namespace\nnodes.</p><p>The built-in template rules are treated as if they were imported\nimplicitly before the stylesheet and so have lower <a href = \"#dt-import-precedence\">import precedence</a> than all other template\nrules.  Thus, the author can override a built-in template rule by including\nan explicit template rule.</p><h2><a name = \"named-templates\" id = \"named-templates\"></a>6 Named Templates</h2><p class = \"element-syntax\"><a name = \"XSLT_element-call-template\" id = \"XSLT_element-call-template\"></a><code>&lt;!--\nCategory: instruction --&gt;<br/>\n&lt;xsl:call-template<br/>\n&nbsp;&nbsp;<b>name</b> = <var>qname</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <a href = \"#XSLT_element-with-param\">xsl:with-param</a>* --&gt;<br/>\n&lt;/xsl:call-template&gt;</code></p><p>Templates can be invoked by name.  An <code>xsl:template</code> element\nwith a <code>name</code> attribute specifies a named template. The value of\nthe <code>name</code> attribute is a <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a>, which is\nexpanded as described in <a href = \"#qname\">[<b>2.4 Qualified Names</b>]</a>.\nIf an <code>xsl:template</code> element has a <code>name</code> attribute, it\nmay, but need not, also have a <code>match</code> attribute.  An\n<code>xsl:call-template</code> element invokes a template by name; it has a\nrequired <code>name</code> attribute that identifies the template to be\ninvoked.  Unlike <code>xsl:apply-templates</code>,\n<code>xsl:call-template</code> does not change the current node or the\ncurrent node list.</p><p>The <code>match</code>, <code>mode</code> and <code>priority</code>\nattributes on an <code>xsl:template</code> element do not affect whether the\ntemplate is invoked by an <code>xsl:call-template</code> element.  Similarly,\nthe <code>name</code> attribute on an <code>xsl:template</code> element does\nnot affect whether the template is invoked by an\n<code>xsl:apply-templates</code> element.</p><p>It is an error if a stylesheet contains more than one template with the\nsame name and same <a href = \"#dt-import-precedence\">import precedence</a>.</p><h2><a name = \"section-Creating-the-Result-Tree\" id = \"section-Creating-the-Result-Tree\"></a>7 Creating the Result\nTree</h2><p>This section describes instructions that directly create nodes in the\nresult tree.</p><h3><a name = \"section-Creating-Elements-and-Attributes\" id = \"section-Creating-Elements-and-Attributes\"></a>7.1 Creating\nElements and Attributes</h3><h4><a name = \"literal-result-element\" id = \"literal-result-element\"></a>7.1.1 Literal Result Elements</h4><p>In a template, an element in the stylesheet that does not belong to the\nXSLT namespace and that is not an extension element (see <a href = \"#extension-element\">[<b>14.1 Extension Elements</b>]</a>) is\ninstantiated to create an element node with the same <a href = \"http://www.w3.org/TR/xpath#dt-expanded-name\">expanded-name</a>.  The\ncontent of the element is a template, which is instantiated to give the\ncontent of the created element node. The created element node will have the\nattribute nodes that were present on the element node in the stylesheet tree,\nother than attributes with names in the XSLT namespace.</p><p>The created element node will also have a copy of the namespace nodes that\nwere present on the element node in the stylesheet tree with the exception of\nany namespace node whose string-value is the XSLT namespace URI\n(<code>http://www.w3.org/1999/XSL/Transform</code>), a namespace URI declared\nas an extension namespace (see <a href = \"#extension-element\">[<b>14.1\nExtension Elements</b>]</a>), or a namespace URI designated as an excluded\nnamespace.  A namespace URI is designated as an excluded namespace by using\nan <code>exclude-result-prefixes</code> attribute on an\n<code>xsl:stylesheet</code> element or an\n<code>xsl:exclude-result-prefixes</code> attribute on a literal result\nelement.  The value of both these attributes is a whitespace-separated list\nof namespace prefixes. The namespace bound to each of the prefixes is\ndesignated as an excluded namespace.  It is an error if there is no namespace\nbound to the prefix on the element bearing the\n<code>exclude-result-prefixes</code> or\n<code>xsl:exclude-result-prefixes</code> attribute.  The default namespace\n(as declared by <code>xmlns</code>) may be designated as an excluded\nnamespace by including <code>#default</code> in the list of namespace\nprefixes.  The designation of a namespace as an excluded namespace is\neffective within the subtree of the stylesheet rooted at the element bearing\nthe <code>exclude-result-prefixes</code> or\n<code>xsl:exclude-result-prefixes</code> attribute; a subtree rooted at an\n<code>xsl:stylesheet</code> element does not include any stylesheets imported\nor included by children of that <code>xsl:stylesheet</code> element.</p><blockquote>\n  <b>NOTE:</b>When a stylesheet uses a namespace declaration only for the\n  purposes of addressing the source tree, specifying the prefix in the\n  <code>exclude-result-prefixes</code> attribute will avoid superfluous\n  namespace declarations in the result tree.</blockquote><p>The value of an attribute of a literal result element is interpreted as an\n<a href = \"#dt-attribute-value-template\">attribute value template</a>: it can\ncontain expressions contained in curly braces (<code>{}</code>).</p><p><a name = \"dt-literal-namespace-uri\" id = \"dt-literal-namespace-uri\"></a>A namespace URI in the stylesheet\ntree that is being used to specify a namespace URI in the result tree is\ncalled a <b>literal namespace URI</b>. This applies to:</p><ul>\n  <li><p>the namespace URI in the expanded-name of a literal result element\n    in the stylesheet</p>\n  </li>\n  <li><p>the namespace URI in the expanded-name of an attribute specified on\n    a literal result element in the stylesheet</p>\n  </li>\n  <li><p>the string-value of a namespace node on a literal result element in\n    the stylesheet</p>\n  </li>\n</ul><p class = \"element-syntax\"><a name = \"XSLT_element-namespace-alias\" id = \"XSLT_element-namespace-alias\"></a><code>&lt;!--\nCategory: top-level-element --&gt;<br/>\n&lt;xsl:namespace-alias<br/>\n&nbsp;&nbsp;<b>stylesheet-prefix</b> = <var>prefix</var> | \"#default\"<br/>\n&nbsp;&nbsp;<b>result-prefix</b> = <var>prefix</var> |\n\"#default\"&nbsp;/&gt;</code></p><p><a name = \"dt-alias\" id = \"dt-alias\"></a>A stylesheet can use the\n<code>xsl:namespace-alias</code> element to declare that one namespace URI is\nan <b>alias</b> for another namespace URI. When a <a href = \"#dt-literal-namespace-uri\">literal namespace URI</a> has been declared\nto be an alias for another namespace URI, then the namespace URI in the\nresult tree will be the namespace URI that the literal namespace URI is an\nalias for, instead of the literal namespace URI itself.  The\n<code>xsl:namespace-alias</code> element declares that the namespace URI\nbound to the prefix specified by the <code>stylesheet-prefix</code> attribute\nis an alias for the namespace URI bound to the prefix specified by the\n<code>result-prefix</code> attribute.  Thus, the\n<code>stylesheet-prefix</code> attribute specifies the namespace URI that\nwill appear in the stylesheet, and the <code>result-prefix</code> attribute\nspecifies the corresponding namespace URI that will appear in the result\ntree.  The default namespace (as declared by <code>xmlns</code>) may be\nspecified by using <code>#default</code> instead of a prefix.  If a namespace\nURI is declared to be an alias for multiple different namespace URIs, then\nthe declaration with the highest <a href = \"#dt-import-precedence\">import\nprecedence</a> is used. It is an error if there is more than one such\ndeclaration.  An XSLT processor may signal the error; if it does not signal\nthe error, it must recover by choosing, from amongst the declarations with\nthe highest import precedence, the one that occurs last in the stylesheet.</p><p>When literal result elements are being used to create element, attribute,\nor namespace nodes that use the XSLT namespace URI, the stylesheet must use\nan alias.  For example, the stylesheet</p><pre>&lt;xsl:stylesheet\n  version=\"1.0\"\n  xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n  xmlns:fo=\"http://www.w3.org/1999/XSL/Format\"\n  xmlns:axsl=\"http://www.w3.org/1999/XSL/TransformAlias\"&gt;\n\n&lt;xsl:namespace-alias stylesheet-prefix=\"axsl\" result-prefix=\"xsl\"/&gt;\n\n&lt;xsl:template match=\"/\"&gt;\n  &lt;axsl:stylesheet&gt;\n    &lt;xsl:apply-templates/&gt;\n  &lt;/axsl:stylesheet&gt;\n&lt;/xsl:template&gt;\n\n&lt;xsl:template match=\"block\"&gt;\n  &lt;axsl:template match=\"{.}\"&gt;\n     &lt;fo:block&gt;&lt;axsl:apply-templates/&gt;&lt;/fo:block&gt;\n  &lt;/axsl:template&gt;\n&lt;/xsl:template&gt;\n\n&lt;/xsl:stylesheet&gt;</pre><p>will generate an XSLT stylesheet from a document of the form:</p><pre>&lt;elements&gt;\n&lt;block&gt;p&lt;/block&gt;\n&lt;block&gt;h1&lt;/block&gt;\n&lt;block&gt;h2&lt;/block&gt;\n&lt;block&gt;h3&lt;/block&gt;\n&lt;block&gt;h4&lt;/block&gt;\n&lt;/elements&gt;</pre><blockquote>\n  <b>NOTE:</b>It may be necessary also to use aliases for namespaces other\n  than the XSLT namespace URI.  For example, literal result elements\n  belonging to a namespace dealing with digital signatures might cause XSLT\n  stylesheets to be mishandled by general-purpose security software; using an\n  alias for the namespace would avoid the possibility of such\nmishandling.</blockquote><h4><a name = \"section-Creating-Elements-with-xsl:element\" id = \"section-Creating-Elements-with-xsl:element\"></a>7.1.2 Creating\nElements with <code>xsl:element</code></h4><p class = \"element-syntax\"><a name = \"XSLT_element-element\" id = \"XSLT_element-element\"></a><code>&lt;!--\nCategory: instruction --&gt;<br/>\n&lt;xsl:element<br/>\n&nbsp;&nbsp;<b>name</b> = { <var>qname</var> }<br/>\n&nbsp;&nbsp;namespace = { <var>uri-reference</var> }<br/>\n&nbsp;&nbsp;use-attribute-sets = <var>qnames</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:element&gt;</code></p><p>The <code>xsl:element</code> element allows an element to be created with\na computed name.  The <a href = \"http://www.w3.org/TR/xpath#dt-expanded-name\">expanded-name</a> of the\nelement to be created is specified by a required <code>name</code> attribute\nand an optional <code>namespace</code> attribute.  The content of the\n<code>xsl:element</code> element is a template for the attributes and\nchildren of the created element.</p><p>The <code>name</code> attribute is interpreted as an <a href = \"#dt-attribute-value-template\">attribute value template</a>. It is an\nerror if the string that results from instantiating the attribute value\ntemplate is not a <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a>.  An XSLT\nprocessor may signal the error; if it does not signal the error, then it must\nrecover by making the the result of instantiating the\n<code>xsl:element</code> element be the sequence of nodes created by\ninstantiating the content of the  <code>xsl:element</code> element, excluding\nany initial attribute nodes. If the <code>namespace</code> attribute is not\npresent then the <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a> is expanded into\nan expanded-name using the namespace declarations in effect for the\n<code>xsl:element</code> element, including any default namespace\ndeclaration.</p><p>If the <code>namespace</code> attribute is present, then it also is\ninterpreted as an <a href = \"#dt-attribute-value-template\">attribute value\ntemplate</a>. The string that results from instantiating the attribute value\ntemplate should be a URI reference.  It is not an error if the string is not\na syntactically legal URI reference.  If the string is empty, then the\nexpanded-name of the element has a null namespace URI.  Otherwise, the string\nis used as the namespace URI of the expanded-name of the element to be\ncreated. The local part of the <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a> specified by the\n<code>name</code> attribute is used as the local part of the expanded-name of\nthe element to be created.</p><p>XSLT processors may make use of the prefix of the <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a> specified in the\n<code>name</code> attribute when selecting the prefix used for outputting the\ncreated element as XML; however, they are not required to do so.</p><h4><a name = \"creating-attributes\" id = \"creating-attributes\"></a>7.1.3 Creating Attributes with\n<code>xsl:attribute</code></h4><p class = \"element-syntax\"><a name = \"XSLT_element-attribute\" id = \"XSLT_element-attribute\"></a><code>&lt;!--\nCategory: instruction --&gt;<br/>\n&lt;xsl:attribute<br/>\n&nbsp;&nbsp;<b>name</b> = { <var>qname</var> }<br/>\n&nbsp;&nbsp;namespace = { <var>uri-reference</var> }&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:attribute&gt;</code></p><p>The <code>xsl:attribute</code> element can be used to add attributes to\nresult elements whether created by literal result elements in the stylesheet\nor by instructions such as <code>xsl:element</code>. The <a href = \"http://www.w3.org/TR/xpath#dt-expanded-name\">expanded-name</a> of the\nattribute to be created is specified by a required <code>name</code>\nattribute and an optional <code>namespace</code> attribute. Instantiating an\n<code>xsl:attribute</code> element adds an attribute node to the containing\nresult element node. The content of the <code>xsl:attribute</code> element is\na template for the value of the created attribute.</p><p>The <code>name</code> attribute is interpreted as an <a href = \"#dt-attribute-value-template\">attribute value template</a>. It is an\nerror if the string that results from instantiating the attribute value\ntemplate is not a <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a> or is the string\n<code>xmlns</code>.  An XSLT processor may signal the error; if it does not\nsignal the error, it must recover by not adding the attribute to the result\ntree. If the <code>namespace</code> attribute is not present, then the <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a> is expanded into\nan expanded-name using the namespace declarations in effect for the\n<code>xsl:attribute</code> element, <i>not</i> including any default\nnamespace declaration.</p><p>If the <code>namespace</code> attribute is present, then it also is\ninterpreted as an <a href = \"#dt-attribute-value-template\">attribute value\ntemplate</a>. The string that results from instantiating it should be a URI\nreference.  It is not an error if the string is not a syntactically legal URI\nreference.  If the string is empty, then the expanded-name of the attribute\nhas a null namespace URI.  Otherwise, the string is used as the namespace URI\nof the expanded-name of the attribute to be created. The local part of the <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a> specified by the\n<code>name</code> attribute is used as the local part of the expanded-name of\nthe attribute to be created.</p><p>XSLT processors may make use of the prefix of the <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a> specified in the\n<code>name</code> attribute when selecting the prefix used for outputting the\ncreated attribute as XML; however, they are not required to do so and, if the\nprefix is <code>xmlns</code>, they must not do so. Thus, although it is not\nan error to do:</p><pre>&lt;xsl:attribute name=\"xmlns:xsl\" namespace=\"whatever\"&gt;http://www.w3.org/1999/XSL/Transform&lt;/xsl:attribute&gt;</pre><p>it will not result in a namespace declaration being output.</p><p>Adding an attribute to an element replaces any existing attribute of that\nelement with the same expanded-name.</p><p>The following are all errors:</p><ul>\n  <li><p>Adding an attribute to an element after children have been added to\n    it; implementations may either signal the error or ignore the\n    attribute.</p>\n  </li>\n  <li><p>Adding an attribute to a node that is not an element;\n    implementations may either signal the error or ignore the attribute.</p>\n  </li>\n  <li><p>Creating nodes other than text nodes during the instantiation of the\n    content of the <code>xsl:attribute</code> element; implementations may\n    either signal the error or ignore the offending nodes.</p>\n  </li>\n</ul><blockquote>\n  <b>NOTE:</b>When an <code>xsl:attribute</code> contains a text node with a\n  newline, then the XML output must contain a character reference. For\n  example,\n  <pre>&lt;xsl:attribute name=\"a\"&gt;x\ny&lt;/xsl:attribute&gt;</pre>\n  will result in the output\n  <pre>a=\"x&amp;#xA;y\"</pre>\n  (or with any equivalent character reference). The XML output cannot be\n  <pre>a=\"x\ny\"</pre>\n  This is because XML 1.0 requires newline characters in attribute values to\n  be normalized into spaces but requires character references to newline\n  characters not to be normalized.  The attribute values in the data model\n  represent the attribute value after normalization.  If a newline occurring\n  in an attribute value in the tree were output as a newline character rather\n  than as character reference, then the attribute value in the tree created\n  by reparsing the XML would contain a space not a newline, which would mean\n  that the tree had not been output correctly.</blockquote><h4><a name = \"attribute-sets\" id = \"attribute-sets\"></a>7.1.4 Named Attribute Sets</h4><p class = \"element-syntax\"><a name = \"XSLT_element-attribute-set\" id = \"XSLT_element-attribute-set\"></a><code>&lt;!--\nCategory: top-level-element --&gt;<br/>\n&lt;xsl:attribute-set<br/>\n&nbsp;&nbsp;<b>name</b> = <var>qname</var> <br/>\n&nbsp;&nbsp;use-attribute-sets = <var>qnames</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <a href = \"#XSLT_element-attribute\">xsl:attribute</a>*\n--&gt;<br/>\n&lt;/xsl:attribute-set&gt;</code></p><p>The <code>xsl:attribute-set</code> element defines a named set of\nattributes.  The <code>name</code> attribute specifies the name of the\nattribute set.  The value of the <code>name</code> attribute is a <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a>, which is\nexpanded as described in <a href = \"#qname\">[<b>2.4 Qualified Names</b>]</a>.\nThe content of the <code>xsl:attribute-set</code> element consists of zero or\nmore <code>xsl:attribute</code> elements that specify the attributes in the\nset.</p><p>Attribute sets are used by specifying a <code>use-attribute-sets</code>\nattribute on <code>xsl:element</code>, <code>xsl:copy</code> (see <a href = \"#copying\">[<b>7.5 Copying</b>]</a>) or <code>xsl:attribute-set</code>\nelements.  The value of the <code>use-attribute-sets</code> attribute is a\nwhitespace-separated list of names of attribute sets.  Each name is specified\nas a <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a>, which\nis expanded as described in <a href = \"#qname\">[<b>2.4 Qualified\nNames</b>]</a>.  Specifying a <code>use-attribute-sets</code> attribute is\nequivalent to adding <code>xsl:attribute</code> elements for each of the\nattributes in each of the named attribute sets to the beginning of the\ncontent of the element with the <code>use-attribute-sets</code> attribute, in\nthe same order in which the names of the attribute sets are specified in the\n<code>use-attribute-sets</code> attribute.  It is an error if use of\n<code>use-attribute-sets</code> attributes on <code>xsl:attribute-set</code>\nelements causes an attribute set to directly or indirectly use itself.</p><p>Attribute sets can also be used by specifying an\n<code>xsl:use-attribute-sets</code> attribute on a literal result element. \nThe value of the <code>xsl:use-attribute-sets</code> attribute is a\nwhitespace-separated list of names of attribute sets. The\n<code>xsl:use-attribute-sets</code> attribute has the same effect as the\n<code>use-attribute-sets</code> attribute on <code>xsl:element</code> with\nthe additional rule that attributes specified on the literal result element\nitself are treated as if they were specified by <code>xsl:attribute</code>\nelements before any actual <code>xsl:attribute</code> elements but after any\n<code>xsl:attribute</code> elements implied by the\n<code>xsl:use-attribute-sets</code> attribute.  Thus, for a literal result\nelement, attributes from attribute sets named in an\n<code>xsl:use-attribute-sets</code> attribute will be added first, in the\norder listed in the attribute; next, attributes specified on the literal\nresult element will be added; finally, any attributes specified by\n<code>xsl:attribute</code> elements will be added.  Since adding an attribute\nto an element replaces any existing attribute of that element with the same\nname, this means that attributes specified in attribute sets can be\noverridden by attributes specified on the literal result element itself.</p><p>The template within each <code>xsl:attribute</code> element in an\n<code>xsl:attribute-set</code> element is instantiated each time the\nattribute set is used; it is instantiated using the same current node and\ncurrent node list as is used for instantiating the element bearing the\n<code>use-attribute-sets</code> or <code>xsl:use-attribute-sets</code>\nattribute. However, it is the position in the stylesheet of the\n<code>xsl:attribute</code> element rather than of the element bearing the\n<code>use-attribute-sets</code> or <code>xsl:use-attribute-sets</code>\nattribute that determines which variable bindings are visible (see <a href = \"#variables\">[<b>11 Variables and Parameters</b>]</a>); thus, only\nvariables and parameters declared by <a href = \"#dt-top-level\">top-level</a>\n<code>xsl:variable</code> and <code>xsl:param</code> elements are visible.</p><p>The following example creates a named attribute set\n<code>title-style</code> and uses it in a template rule.</p><pre>&lt;xsl:template match=\"chapter/heading\"&gt;\n  &lt;fo:block quadding=\"start\" xsl:use-attribute-sets=\"title-style\"&gt;\n    &lt;xsl:apply-templates/&gt;\n  &lt;/fo:block&gt;\n&lt;/xsl:template&gt;\n\n&lt;xsl:attribute-set name=\"title-style\"&gt;\n  &lt;xsl:attribute name=\"font-size\"&gt;12pt&lt;/xsl:attribute&gt;\n  &lt;xsl:attribute name=\"font-weight\"&gt;bold&lt;/xsl:attribute&gt;\n&lt;/xsl:attribute-set&gt;</pre><p>Multiple definitions of an attribute set with the same expanded-name are\nmerged.  An attribute from a definition that has higher <a href = \"#dt-import-precedence\">import precedence</a> takes precedence over an\nattribute from a definition that has lower <a href = \"#dt-import-precedence\">import precedence</a>.  It is an error if there\nare two attribute sets that have the same expanded-name and equal import\nprecedence and that both contain the same attribute, unless there is a\ndefinition of the attribute set with higher <a href = \"#dt-import-precedence\">import precedence</a> that also contains the\nattribute.  An XSLT processor may signal the error; if it does not signal the\nerror, it must recover by choosing from amongst the definitions that specify\nthe attribute that have the highest import precedence the one that was\nspecified last in the stylesheet.  Where the attributes in an attribute set\nwere specified is relevant only in merging the attributes into the attribute\nset; it makes no difference when the attribute set is used.</p><h3><a name = \"section-Creating-Text\" id = \"section-Creating-Text\"></a>7.2 Creating Text</h3><p>A template can also contain text nodes.  Each text node in a template\nremaining after whitespace has been stripped as specified in <a href = \"#strip\">[<b>3.4 Whitespace Stripping</b>]</a> will create a text node\nwith the same string-value in the result tree.  Adjacent text nodes in the\nresult tree are automatically merged.</p><p>Note that text is processed at the tree level. Thus, markup of\n<code>&amp;lt;</code> in a template will be represented in the stylesheet\ntree by a text node that includes the character <code>&lt;</code>. This will\ncreate a text node in the result tree that contains a <code>&lt;</code>\ncharacter, which will be represented by the markup <code>&amp;lt;</code> (or\nan equivalent character reference) when the result tree is externalized as an\nXML document (unless output escaping is disabled as described in <a href = \"#disable-output-escaping\">[<b>16.4 Disabling Output\nEscaping</b>]</a>).</p><p class = \"element-syntax\"><a name = \"XSLT_element-text\" id = \"XSLT_element-text\"></a><code>&lt;!-- Category:\ninstruction --&gt;<br/>\n&lt;xsl:text<br/>\n&nbsp;&nbsp;disable-output-escaping = \"yes\" | \"no\"&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: #PCDATA --&gt;<br/>\n&lt;/xsl:text&gt;</code></p><p>Literal data characters may also be wrapped in an <code>xsl:text</code>\nelement.  This wrapping may change what whitespace characters are stripped\n(see <a href = \"#strip\">[<b>3.4 Whitespace Stripping</b>]</a>) but does not\naffect how the characters are handled by the XSLT processor thereafter.</p><blockquote>\n  <b>NOTE:</b>The <code>xml:lang</code> and <code>xml:space</code> attributes\n  are not treated specially by XSLT. In particular,\n  <ul>\n    <li><p>it is the responsibility of the stylesheet author explicitly to\n      generate any <code>xml:lang</code> or <code>xml:space</code> attributes\n      that are needed in the result;</p>\n    </li>\n    <li><p>specifying an <code>xml:lang</code> or <code>xml:space</code>\n      attribute on an element in the XSLT namespace will not cause any\n      <code>xml:lang</code> or <code>xml:space</code> attributes to appear in\n      the result.</p>\n    </li>\n  </ul>\n</blockquote><h3><a name = \"section-Creating-Processing-Instructions\" id = \"section-Creating-Processing-Instructions\"></a>7.3 Creating\nProcessing Instructions</h3><p class = \"element-syntax\"><a name = \"XSLT_element-processing-instruction\" id = \"XSLT_element-processing-instruction\"></a><code>&lt;!-- Category: instruction\n--&gt;<br/>\n&lt;xsl:processing-instruction<br/>\n&nbsp;&nbsp;<b>name</b> = { <var>ncname</var> }&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:processing-instruction&gt;</code></p><p>The <code>xsl:processing-instruction</code> element is instantiated to\ncreate a processing instruction node.  The content of the\n<code>xsl:processing-instruction</code> element is a template for the\nstring-value of the processing instruction node.  The\n<code>xsl:processing-instruction</code> element has a required\n<code>name</code> attribute that specifies the name of the processing\ninstruction node.  The value of the <code>name</code> attribute is\ninterpreted as an <a href = \"#dt-attribute-value-template\">attribute value\ntemplate</a>.</p><p>For example, this</p><pre>&lt;xsl:processing-instruction name=\"xml-stylesheet\"&gt;href=\"book.css\" type=\"text/css\"&lt;/xsl:processing-instruction&gt;</pre><p>would create the processing instruction</p><pre>&lt;?xml-stylesheet href=\"book.css\" type=\"text/css\"?&gt;</pre><p>It is an error if the string that results from instantiating the\n<code>name</code> attribute is not both an <a href = \"http://www.w3.org/TR/REC-xml-names#NT-NCName\">NCName</a> and a <a href = \"http://www.w3.org/TR/REC-xml#NT-PITarget\">PITarget</a>.  An XSLT\nprocessor may signal the error; if it does not signal the error, it must\nrecover by not adding the processing instruction to the result tree.</p><blockquote>\n  <b>NOTE:</b>This means that <code>xsl:processing-instruction</code> cannot\n  be used to output an XML declaration.  The <code>xsl:output</code> element\n  should be used instead (see <a href = \"#output\">[<b>16\nOutput</b>]</a>).</blockquote><p>It is an error if instantiating the content of\n<code>xsl:processing-instruction</code> creates nodes other than text nodes. \nAn XSLT processor may signal the error; if it does not signal the error, it\nmust recover by ignoring the offending nodes together with their content.</p><p>It is an error if the result of instantiating the content of the\n<code>xsl:processing-instruction</code> contains the string\n<code>?&gt;</code>.  An XSLT processor may signal the error; if it does not\nsignal the error, it must recover by inserting a space after any occurrence\nof <code>?</code> that is followed by a <code>&gt;</code>.</p><h3><a name = \"section-Creating-Comments\" id = \"section-Creating-Comments\"></a>7.4 Creating Comments</h3><p class = \"element-syntax\"><a name = \"XSLT_element-comment\" id = \"XSLT_element-comment\"></a><code>&lt;!--\nCategory: instruction --&gt;<br/>\n&lt;xsl:comment&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:comment&gt;</code></p><p>The <code>xsl:comment</code> element is instantiated to create a comment\nnode in the result tree.  The content of the <code>xsl:comment</code> element\nis a template for the string-value of the comment node.</p><p>For example, this</p><pre>&lt;xsl:comment&gt;This file is automatically generated. Do not edit!&lt;/xsl:comment&gt;</pre><p>would create the comment</p><pre>&lt;!--This file is automatically generated. Do not edit!--&gt;</pre><p>It is an error if instantiating the content of <code>xsl:comment</code>\ncreates nodes other than text nodes.  An XSLT processor may signal the error;\nif it does not signal the error, it must recover by ignoring the offending\nnodes together with their content.</p><p>It is an error if the result of instantiating the content of the\n<code>xsl:comment</code> contains the string <code>--</code> or ends with\n<code>-</code>.  An XSLT processor may signal the error; if it does not\nsignal the error, it must recover by inserting a space after any occurrence\nof <code>-</code> that is followed by another <code>-</code> or that ends the\ncomment.</p><h3><a name = \"copying\" id = \"copying\"></a>7.5 Copying</h3><p class = \"element-syntax\"><a name = \"XSLT_element-copy\" id = \"XSLT_element-copy\"></a><code>&lt;!-- Category:\ninstruction --&gt;<br/>\n&lt;xsl:copy<br/>\n&nbsp;&nbsp;use-attribute-sets = <var>qnames</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:copy&gt;</code></p><p>The <code>xsl:copy</code> element provides an easy way of copying the\ncurrent node. Instantiating the <code>xsl:copy</code> element creates a copy\nof the current node.  The namespace nodes of the current node are\nautomatically copied as well, but the attributes and children of the node are\nnot automatically copied.  The content of the <code>xsl:copy</code> element\nis a template for the attributes and children of the created node; the\ncontent is instantiated only for nodes of types that can have attributes or\nchildren (i.e. root nodes and element nodes).</p><p>The <code>xsl:copy</code> element may have a\n<code>use-attribute-sets</code> attribute (see <a href = \"#attribute-sets\">[<b>7.1.4 Named Attribute Sets</b>]</a>). This is used\nonly when copying element nodes.</p><p>The root node is treated specially because the root node of the result\ntree is created implicitly.  When the current node is the root node,\n<code>xsl:copy</code> will not create a root node, but will just use the\ncontent template.</p><p>For example, the identity transformation can be written using\n<code>xsl:copy</code> as follows:</p><pre>&lt;xsl:template match=\"@*|node()\"&gt;\n  &lt;xsl:copy&gt;\n    &lt;xsl:apply-templates select=\"@*|node()\"/&gt;\n  &lt;/xsl:copy&gt;\n&lt;/xsl:template&gt;</pre><p>When the current node is an attribute, then if it would be an error to use\n<code>xsl:attribute</code> to create an attribute with the same name as the\ncurrent node, then it is also an error to use <code>xsl:copy</code> (see <a href = \"#creating-attributes\">[<b>7.1.3 Creating Attributes with\n<code>xsl:attribute</code></b>]</a>).</p><p>The following example shows how <code>xml:lang</code> attributes can be\neasily copied through from source to result. If a stylesheet defines the\nfollowing named template:</p><pre>&lt;xsl:template name=\"apply-templates-copy-lang\"&gt;\n &lt;xsl:for-each select=\"@xml:lang\"&gt;\n   &lt;xsl:copy/&gt;\n &lt;/xsl:for-each&gt;\n &lt;xsl:apply-templates/&gt;\n&lt;/xsl:template&gt;</pre><p>then it can simply do</p><pre>&lt;xsl:call-template name=\"apply-templates-copy-lang\"/&gt;</pre><p>instead of</p><pre>&lt;xsl:apply-templates/&gt;</pre><p>when it wants to copy the <code>xml:lang</code> attribute.</p><h3><a name = \"section-Computing-Generated-Text\" id = \"section-Computing-Generated-Text\"></a>7.6 Computing Generated\nText</h3><p>Within a template, the <code>xsl:value-of</code> element can be used to\ncompute generated text, for example by extracting text from the source tree\nor by inserting the value of a variable.  The <code>xsl:value-of</code>\nelement does this with an <a href = \"#dt-expression\">expression</a> that is\nspecified as the value of the <code>select</code> attribute.  Expressions can\nalso be used inside attribute values of literal result elements by enclosing\nthe expression in curly braces (<code>{}</code>).</p><h4><a name = \"value-of\" id = \"value-of\"></a>7.6.1 Generating Text with\n<code>xsl:value-of</code></h4><p class = \"element-syntax\"><a name = \"XSLT_element-value-of\" id = \"XSLT_element-value-of\"></a><code>&lt;!--\nCategory: instruction --&gt;<br/>\n&lt;xsl:value-of<br/>\n&nbsp;&nbsp;<b>select</b> = <var>string-expression</var> <br/>\n&nbsp;&nbsp;disable-output-escaping = \"yes\" | \"no\"&nbsp;/&gt;</code></p><p>The <code>xsl:value-of</code> element is instantiated to create a text\nnode in the result tree.  The required <code>select</code> attribute is an <a href = \"#dt-expression\">expression</a>; this expression is evaluated and the\nresulting object is converted to a string as if by a call to the <b><a href = \"http://www.w3.org/TR/xpath#function-string\">string</a></b> function.\nThe string specifies the string-value of the created text node.  If the\nstring is empty, no text node will be created.  The created text node will be\nmerged with any adjacent text nodes.</p><p>The <code>xsl:copy-of</code> element can be used to copy a node-set over\nto the result tree without converting it to a string. See <a href = \"#copy-of\">[<b>11.3 Using Values of Variables and Parameters with\n<code>xsl:copy-of</code></b>]</a>.</p><p>For example, the following creates an HTML paragraph from a\n<code>person</code> element with <code>given-name</code> and\n<code>family-name</code> attributes.  The paragraph will contain the value of\nthe <code>given-name</code> attribute of the current node followed by a space\nand the value of the <code>family-name</code> attribute of the current\nnode.</p><pre>&lt;xsl:template match=\"person\"&gt;\n  &lt;p&gt;\n   &lt;xsl:value-of select=\"@given-name\"/&gt;\n   &lt;xsl:text&gt; &lt;/xsl:text&gt;\n   &lt;xsl:value-of select=\"@family-name\"/&gt;\n  &lt;/p&gt;\n&lt;/xsl:template&gt;</pre><p>For another example, the following creates an HTML paragraph from a\n<code>person</code> element with <code>given-name</code> and\n<code>family-name</code> children elements.  The paragraph will contain the\nstring-value of the first <code>given-name</code> child element of the\ncurrent node followed by a space and the string-value of the first\n<code>family-name</code> child element of the current node.</p><pre>&lt;xsl:template match=\"person\"&gt;\n  &lt;p&gt;\n   &lt;xsl:value-of select=\"given-name\"/&gt;\n   &lt;xsl:text&gt; &lt;/xsl:text&gt;\n   &lt;xsl:value-of select=\"family-name\"/&gt;\n  &lt;/p&gt;\n&lt;/xsl:template&gt;</pre><p>The following precedes each <code>procedure</code> element with a\nparagraph containing the security level of the procedure.  It assumes that\nthe security level that applies to a procedure is determined by a\n<code>security</code> attribute on the procedure element or on an ancestor\nelement of the procedure. It also assumes that if more than one such element\nhas a <code>security</code> attribute then the security level is determined\nby the element that is closest to the procedure.</p><pre>&lt;xsl:template match=\"procedure\"&gt;\n  &lt;fo:block&gt;\n    &lt;xsl:value-of select=\"ancestor-or-self::*[@security][1]/@security\"/&gt;\n  &lt;/fo:block&gt;\n  &lt;xsl:apply-templates/&gt;\n&lt;/xsl:template&gt;</pre><h4><a name = \"attribute-value-templates\" id = \"attribute-value-templates\"></a>7.6.2 Attribute Value\nTemplates</h4><p><a name = \"dt-attribute-value-template\" id = \"dt-attribute-value-template\"></a>In an attribute value that is\ninterpreted as an <b>attribute value template</b>, such as an attribute of a\nliteral result element, an <a href = \"#dt-expression\">expression</a> can be\nused by surrounding the expression with curly braces (<code>{}</code>).  The\nattribute value template is instantiated by replacing the expression together\nwith surrounding curly braces by the result of evaluating the expression and\nconverting the resulting object to a string as if by a call to the <b><a href = \"http://www.w3.org/TR/xpath#function-string\">string</a></b> function. \nCurly braces are not recognized in an attribute value in an XSLT stylesheet\nunless the attribute is specifically stated to be one that is interpreted as\nan attribute value template; in an element syntax summary, the value of such\nattributes is surrounded by curly braces.</p><blockquote>\n  <b>NOTE:</b>Not all attributes are interpreted as attribute value\n  templates.  Attributes whose value is an expression or pattern, attributes\n  of <a href = \"#dt-top-level\">top-level</a> elements and attributes that refer\n  to named XSLT objects are not interpreted as attribute value templates. In\n  addition, <code>xmlns</code> attributes are not interpreted as attribute\n  value templates; it would not be conformant with the XML Namespaces\n  Recommendation to do this.</blockquote><p>The following example creates an <code>img</code> result element from a\n<code>photograph</code> element in the source; the value of the\n<code>src</code> attribute of the <code>img</code> element is computed from\nthe value of the <code>image-dir</code> variable and the string-value of the\n<code>href</code> child of the <code>photograph</code> element; the value of\nthe <code>width</code> attribute of the <code>img</code> element is computed\nfrom the value of the <code>width</code> attribute of the <code>size</code>\nchild of the <code>photograph</code> element:</p><pre>&lt;xsl:variable name=\"image-dir\"&gt;/images&lt;/xsl:variable&gt;\n\n&lt;xsl:template match=\"photograph\"&gt;\n&lt;img src=\"{$image-dir}/{href}\" width=\"{size/@width}\"/&gt;\n&lt;/xsl:template&gt;</pre><p>With this source</p><pre>&lt;photograph&gt;\n  &lt;href&gt;headquarters.jpg&lt;/href&gt;\n  &lt;size width=\"300\"/&gt;\n&lt;/photograph&gt;</pre><p>the result would be</p><pre>&lt;img src=\"/images/headquarters.jpg\" width=\"300\"/&gt;</pre><p>When an attribute value template is instantiated, a double left or right\ncurly brace outside an expression will be replaced by a single curly brace. \nIt is an error if a right curly brace occurs in an attribute value template\noutside an expression without being followed by a second right curly brace. \nA right curly brace inside a <a href = \"http://www.w3.org/TR/xpath#NT-Literal\">Literal</a> in an expression is\nnot recognized as terminating the expression.</p><p>Curly braces are <i>not</i> recognized recursively inside expressions. \nFor example:</p><pre style = \"color: red\">&lt;a href=\"#{id({@ref})/title}\"&gt;</pre><p>is <i>not</i> allowed.  Instead, use simply:</p><pre>&lt;a href=\"#{id(@ref)/title}\"&gt;</pre><h3><a name = \"number\" id = \"number\"></a>7.7 Numbering</h3><p class = \"element-syntax\"><a name = \"XSLT_element-number\" id = \"XSLT_element-number\"></a><code>&lt;!--\nCategory: instruction --&gt;<br/>\n&lt;xsl:number<br/>\n&nbsp;&nbsp;level = \"single\" | \"multiple\" | \"any\"<br/>\n&nbsp;&nbsp;count = <var>pattern</var> <br/>\n&nbsp;&nbsp;from = <var>pattern</var> <br/>\n&nbsp;&nbsp;value = <var>number-expression</var> <br/>\n&nbsp;&nbsp;format = { <var>string</var> }<br/>\n&nbsp;&nbsp;lang = { <var>nmtoken</var> }<br/>\n&nbsp;&nbsp;letter-value = { \"alphabetic\" | \"traditional\" }<br/>\n&nbsp;&nbsp;grouping-separator = { <var>char</var> }<br/>\n&nbsp;&nbsp;grouping-size = { <var>number</var> }&nbsp;/&gt;</code></p><p>The <code>xsl:number</code> element is used to insert a formatted number\ninto the result tree.  The number to be inserted may be specified by an\nexpression. The <code>value</code> attribute contains an <a href = \"#dt-expression\">expression</a>.  The expression is evaluated and the\nresulting object is converted to a number as if by a call to the <b><a href = \"http://www.w3.org/TR/xpath#function-number\">number</a></b> function. \nThe number is rounded to an integer and then converted to a string using the\nattributes specified in <a href = \"#convert\">[<b>7.7.1 Number to String\nConversion Attributes</b>]</a>; in this context, the value of each of these\nattributes is interpreted as an <a href = \"#dt-attribute-value-template\">attribute value template</a>.  After\nconversion, the resulting string is inserted in the result tree. For example,\nthe following example numbers a sorted list:</p><pre>&lt;xsl:template match=\"items\"&gt;\n  &lt;xsl:for-each select=\"item\"&gt;\n    &lt;xsl:sort select=\".\"/&gt;\n    &lt;p&gt;\n      &lt;xsl:number value=\"position()\" format=\"1. \"/&gt;\n      &lt;xsl:value-of select=\".\"/&gt;\n    &lt;/p&gt;\n  &lt;/xsl:for-each&gt;\n&lt;/xsl:template&gt;</pre><p>If no <code>value</code> attribute is specified, then the\n<code>xsl:number</code> element inserts a number based on the position of the\ncurrent node in the source tree. The following attributes control how the\ncurrent node is to be numbered:</p><ul>\n  <li><p>The <code>level</code> attribute specifies what levels of the source\n    tree should be considered; it has the values <code>single</code>,\n    <code>multiple</code> or <code>any</code>. The default is\n    <code>single</code>.</p>\n  </li>\n  <li><p>The <code>count</code> attribute is a pattern that specifies what\n    nodes should be counted at those levels.  If <code>count</code> attribute\n    is not specified, then it defaults to the pattern that matches any node\n    with the same node type as the current node and, if the current node has\n    an expanded-name, with the same expanded-name as the current node.</p>\n  </li>\n  <li><p>The <code>from</code> attribute is a pattern that specifies where\n    counting starts.</p>\n  </li>\n</ul><p>In addition, the attributes specified in <a href = \"#convert\">[<b>7.7.1\nNumber to String Conversion Attributes</b>]</a> are used for number to string\nconversion, as in the case when the <code>value</code> attribute is\nspecified.</p><p>The <code>xsl:number</code> element first constructs a list of positive\nintegers using the <code>level</code>, <code>count</code> and\n<code>from</code> attributes:</p><ul>\n  <li><p>When <code>level=\"single\"</code>, it goes up to the first node in\n    the ancestor-or-self axis that matches the <code>count</code> pattern,\n    and constructs a list of length one containing one plus the number of\n    preceding siblings of that ancestor that match the <code>count</code>\n    pattern. If there is no such ancestor, it constructs an empty list.  If\n    the <code>from</code> attribute is specified, then the only ancestors\n    that are searched are those that are descendants of the nearest ancestor\n    that matches the <code>from</code> pattern. Preceding siblings has the\n    same meaning here as with the <code>preceding-sibling</code> axis.</p>\n  </li>\n  <li><p>When <code>level=\"multiple\"</code>, it constructs a list of all\n    ancestors of the current node in document order followed by the element\n    itself; it then selects from the list those nodes that match the\n    <code>count</code> pattern; it then maps each node in the list to one\n    plus the number of preceding siblings of that node that match the\n    <code>count</code> pattern.  If the <code>from</code> attribute is\n    specified, then the only ancestors that are searched are those that are\n    descendants of the nearest ancestor that matches the <code>from</code>\n    pattern. Preceding siblings has the same meaning here as with the\n    <code>preceding-sibling</code> axis.</p>\n  </li>\n  <li><p>When <code>level=\"any\"</code>, it constructs a list of length one\n    containing the number of nodes that match the <code>count</code> pattern\n    and belong to the set containing the current node and all nodes at any\n    level of the document that are before the current node in document order,\n    excluding any namespace and attribute nodes (in other words the union of\n    the members of the <code>preceding</code> and\n    <code>ancestor-or-self</code> axes). If the <code>from</code> attribute\n    is specified, then only nodes after the first node before the current\n    node that match the <code>from</code> pattern are considered.</p>\n  </li>\n</ul><p>The list of numbers is then converted into a string using the attributes\nspecified in <a href = \"#convert\">[<b>7.7.1 Number to String Conversion\nAttributes</b>]</a>; in this context, the value of each of these attributes\nis interpreted as an <a href = \"#dt-attribute-value-template\">attribute value\ntemplate</a>.  After conversion, the resulting string is inserted in the\nresult tree.</p><p>The following would number the items in an ordered list:</p><pre>&lt;xsl:template match=\"ol/item\"&gt;\n  &lt;fo:block&gt;\n    &lt;xsl:number/&gt;&lt;xsl:text&gt;. &lt;/xsl:text&gt;&lt;xsl:apply-templates/&gt;\n  &lt;/fo:block&gt;\n&lt;xsl:template&gt;</pre><p>The following two rules would number <code>title</code> elements. This is\nintended for a document that contains a sequence of chapters followed by a\nsequence of appendices, where both chapters and appendices contain sections,\nwhich in turn contain subsections. Chapters are numbered 1, 2, 3; appendices\nare numbered A, B, C; sections in chapters are numbered 1.1, 1.2, 1.3;\nsections in appendices are numbered A.1, A.2, A.3.</p><pre>&lt;xsl:template match=\"title\"&gt;\n  &lt;fo:block&gt;\n     &lt;xsl:number level=\"multiple\"\n                 count=\"chapter|section|subsection\"\n                 format=\"1.1 \"/&gt;\n     &lt;xsl:apply-templates/&gt;\n  &lt;/fo:block&gt;\n&lt;/xsl:template&gt;\n\n&lt;xsl:template match=\"appendix//title\" priority=\"1\"&gt;\n  &lt;fo:block&gt;\n     &lt;xsl:number level=\"multiple\"\n                 count=\"appendix|section|subsection\"\n                 format=\"A.1 \"/&gt;\n     &lt;xsl:apply-templates/&gt;\n  &lt;/fo:block&gt;\n&lt;/xsl:template&gt;</pre><p>The following example numbers notes sequentially within a chapter:</p><pre>&lt;xsl:template match=\"note\"&gt;\n  &lt;fo:block&gt;\n     &lt;xsl:number level=\"any\" from=\"chapter\" format=\"(1) \"/&gt;\n     &lt;xsl:apply-templates/&gt;\n  &lt;/fo:block&gt;\n&lt;/xsl:template&gt;</pre><p>The following example would number <code>H4</code> elements in HTML with a\nthree-part label:</p><pre>&lt;xsl:template match=\"H4\"&gt;\n &lt;fo:block&gt;\n   &lt;xsl:number level=\"any\" from=\"H1\" count=\"H2\"/&gt;\n   &lt;xsl:text&gt;.&lt;/xsl:text&gt;\n   &lt;xsl:number level=\"any\" from=\"H2\" count=\"H3\"/&gt;\n   &lt;xsl:text&gt;.&lt;/xsl:text&gt;\n   &lt;xsl:number level=\"any\" from=\"H3\" count=\"H4\"/&gt;\n   &lt;xsl:text&gt; &lt;/xsl:text&gt;\n   &lt;xsl:apply-templates/&gt;\n &lt;/fo:block&gt;\n&lt;/xsl:template&gt;</pre><h4><a name = \"convert\" id = \"convert\"></a>7.7.1 Number to String Conversion Attributes</h4><p>The following attributes are used to control conversion of a list of\nnumbers into a string. The numbers are integers greater than 0. The\nattributes are all optional.</p><p>The main attribute is <code>format</code>.  The default value for the\n<code>format</code> attribute is <code>1</code>.  The <code>format</code>\nattribute is split into a sequence of tokens where each token is a maximal\nsequence of alphanumeric characters or a maximal sequence of non-alphanumeric\ncharacters.  Alphanumeric means any character that has a Unicode category of\nNd, Nl, No, Lu, Ll, Lt, Lm or Lo.  The alphanumeric tokens (format tokens)\nspecify the format to be used for each number in the list.  If the first\ntoken is a non-alphanumeric token, then the constructed string will start\nwith that token; if the last token is non-alphanumeric token, then the\nconstructed string will end with that token.  Non-alphanumeric tokens that\noccur between two format tokens are separator tokens that are used to join\nnumbers in the list.  The <var>n</var>th format token will be used to format\nthe <var>n</var>th number in the list.  If there are more numbers than format\ntokens, then the last format token will be used to format remaining numbers. \nIf there are no format tokens, then a format token of <code>1</code> is used\nto format all numbers.  The format token specifies the string to be used to\nrepresent the number 1.  Each number after the first will be separated from\nthe preceding number by the separator token preceding the format token used\nto format that number, or, if there are no separator tokens, then by\n<code>.</code> (a period character).</p><p>Format tokens are a superset of the allowed values for the\n<code>type</code> attribute for the <code>OL</code> element in HTML 4.0 and\nare interpreted as follows:</p><ul>\n  <li><p>Any token where the last character has a decimal digit value of 1\n    (as specified in the Unicode character property database), and the\n    Unicode value of preceding characters is one less than the Unicode value\n    of the last character generates a decimal representation of the number\n    where each number is at least as long as the format token.  Thus, a\n    format token <code>1</code> generates the sequence <code>1 2 ... 10 11 12\n    ...</code>, and a format token <code>01</code> generates the sequence\n    <code>01 02 ... 09 10 11 12 ... 99 100 101</code>.</p>\n  </li>\n  <li><p>A format token <code>A</code> generates the sequence <code>A B C ...\n    Z AA AB AC...</code>.</p>\n  </li>\n  <li><p>A format token <code>a</code> generates the sequence <code>a b c ...\n    z aa ab ac...</code>.</p>\n  </li>\n  <li><p>A format token <code>i</code> generates the sequence <code>i ii iii\n    iv v vi vii viii ix x ...</code>.</p>\n  </li>\n  <li><p>A format token <code>I</code> generates the sequence <code>I II III\n    IV V VI VII VIII IX X ...</code>.</p>\n  </li>\n  <li><p>Any other format token indicates a numbering sequence that starts\n    with that token.  If an implementation does not support a numbering\n    sequence that starts with that token, it must use a format token of\n    <code>1</code>.</p>\n  </li>\n</ul><p>When numbering with an alphabetic sequence, the <code>lang</code>\nattribute specifies which language's alphabet is to be used; it has the same\nrange of values as <code>xml:lang</code> <a href = \"#XML\">[XML]</a>; if no\n<code>lang</code> value is specified, the language should be determined from\nthe system environment.  Implementers should document for which languages\nthey support numbering.</p><blockquote>\n  <b>NOTE:</b>Implementers should not make any assumptions about how\n  numbering works in particular languages and should properly research the\n  languages that they wish to support.  The numbering conventions of many\n  languages are very different from English.</blockquote><p>The <code>letter-value</code> attribute disambiguates between numbering\nsequences that use letters.  In many languages there are two commonly used\nnumbering sequences that use letters.  One numbering sequence assigns numeric\nvalues to letters in alphabetic sequence, and the other assigns numeric\nvalues to each letter in some other manner traditional in that language.  In\nEnglish, these would correspond to the numbering sequences specified by the\nformat tokens <code>a</code> and <code>i</code>.  In some languages, the\nfirst member of each sequence is the same, and so the format token alone\nwould be ambiguous.  A value of <code>alphabetic</code> specifies the\nalphabetic sequence; a value of <code>traditional</code> specifies the other\nsequence.  If the <code>letter-value</code> attribute is not specified, then\nit is implementation-dependent how any ambiguity is resolved.</p><blockquote>\n  <b>NOTE:</b>It is possible for two conforming XSLT processors not to\n  convert a number to exactly the same string.  Some XSLT processors may not\n  support some languages.  Furthermore, there may be variations possible in\n  the way conversions are performed for any particular language that are not\n  specifiable by the attributes on <code>xsl:number</code>. Future versions\n  of XSLT may provide additional attributes to provide control over these\n  variations.  Implementations may also use implementation-specific\n  namespaced attributes on <code>xsl:number</code> for this.</blockquote><p>The <code>grouping-separator</code> attribute gives the separator used as\na grouping (e.g. thousands) separator in decimal numbering sequences, and the\noptional <code>grouping-size</code> specifies the size (normally 3) of the\ngrouping.  For example, <code>grouping-separator=\",\"</code> and\n<code>grouping-size=\"3\"</code> would produce numbers of the form\n<code>1,000,000</code>.  If only one of the <code>grouping-separator</code>\nand <code>grouping-size</code> attributes is specified, then it is\nignored.</p><p>Here are some examples of conversion specifications:</p><ul>\n  <li><p><code>format=\"&amp;#x30A2;\"</code> specifies Katakana numbering</p>\n  </li>\n  <li><p><code>format=\"&amp;#x30A4;\"</code> specifies Katakana numbering in\n    the \"iroha\" order</p>\n  </li>\n  <li><p><code>format=\"&amp;#x0E51;\"</code> specifies numbering with Thai\n    digits</p>\n  </li>\n  <li><p><code>format=\"&amp;#x05D0;\" letter-value=\"traditional\"</code>\n    specifies \"traditional\" Hebrew numbering</p>\n  </li>\n  <li><p><code>format=\"&amp;#x10D0;\" letter-value=\"traditional\"</code>\n    specifies Georgian numbering</p>\n  </li>\n  <li><p><code>format=\"&amp;#x03B1;\" letter-value=\"traditional\"</code>\n    specifies \"classical\" Greek numbering</p>\n  </li>\n  <li><p><code>format=\"&amp;#x0430;\" letter-value=\"traditional\"</code>\n    specifies Old Slavic numbering</p>\n  </li>\n</ul><h2><a name = \"for-each\" id = \"for-each\"></a>8 Repetition</h2><p class = \"element-syntax\"><a name = \"XSLT_element-for-each\" id = \"XSLT_element-for-each\"></a><code>&lt;!--\nCategory: instruction --&gt;<br/>\n&lt;xsl:for-each<br/>\n&nbsp;&nbsp;<b>select</b> = <var>node-set-expression</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: (<a href = \"#XSLT_element-sort\">xsl:sort</a>*,\n<var>template</var>) --&gt;<br/>\n&lt;/xsl:for-each&gt;</code></p><p>When the result has a known regular structure, it is useful to be able to\nspecify directly the template for selected nodes.  The\n<code>xsl:for-each</code> instruction contains a template, which is\ninstantiated for each node selected by the <a href = \"#dt-expression\">expression</a> specified by the <code>select</code>\nattribute. The <code>select</code> attribute is required.  The expression\nmust evaluate to a node-set.  The template is instantiated with the selected\nnode as the <a href = \"#dt-current-node\">current node</a>, and with a list of\nall of the selected nodes as the <a href = \"#dt-current-node-list\">current node\nlist</a>.  The nodes are processed in document order, unless a sorting\nspecification is present (see <a href = \"#sorting\">[<b>10 Sorting</b>]</a>).</p><p>For example, given an XML document with this structure</p><pre>&lt;customers&gt;\n  &lt;customer&gt;\n    &lt;name&gt;...&lt;/name&gt;\n    &lt;order&gt;...&lt;/order&gt;\n    &lt;order&gt;...&lt;/order&gt;\n  &lt;/customer&gt;\n  &lt;customer&gt;\n    &lt;name&gt;...&lt;/name&gt;\n    &lt;order&gt;...&lt;/order&gt;\n    &lt;order&gt;...&lt;/order&gt;\n  &lt;/customer&gt;\n&lt;/customers&gt;</pre><p>the following would create an HTML document containing a table with a row\nfor each <code>customer</code> element</p><pre>&lt;xsl:template match=\"/\"&gt;\n  &lt;html&gt;\n    &lt;head&gt;\n      &lt;title&gt;Customers&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n      &lt;table&gt;\n        &lt;tbody&gt;\n          &lt;xsl:for-each select=\"customers/customer\"&gt;\n            &lt;tr&gt;\n              &lt;th&gt;\n                &lt;xsl:apply-templates select=\"name\"/&gt;\n              &lt;/th&gt;\n              &lt;xsl:for-each select=\"order\"&gt;\n                &lt;td&gt;\n                  &lt;xsl:apply-templates/&gt;\n                &lt;/td&gt;\n              &lt;/xsl:for-each&gt;\n            &lt;/tr&gt;\n          &lt;/xsl:for-each&gt;\n        &lt;/tbody&gt;\n      &lt;/table&gt;\n    &lt;/body&gt;\n  &lt;/html&gt;\n&lt;/xsl:template&gt;</pre><h2><a name = \"section-Conditional-Processing\" id = \"section-Conditional-Processing\"></a>9 Conditional Processing</h2><p>There are two instructions in XSLT that support conditional processing in\na template: <code>xsl:if</code> and <code>xsl:choose</code>. The\n<code>xsl:if</code> instruction provides simple if-then conditionality; the\n<code>xsl:choose</code> instruction supports selection of one choice when\nthere are several possibilities.</p><h3><a name = \"section-Conditional-Processing-with-xsl:if\" id = \"section-Conditional-Processing-with-xsl:if\"></a>9.1 Conditional\nProcessing with <code>xsl:if</code></h3><p class = \"element-syntax\"><a name = \"XSLT_element-if\" id = \"XSLT_element-if\"></a><code>&lt;!-- Category:\ninstruction --&gt;<br/>\n&lt;xsl:if<br/>\n&nbsp;&nbsp;<b>test</b> = <var>boolean-expression</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:if&gt;</code></p><p>The <code>xsl:if</code> element has a <code>test</code> attribute, which\nspecifies an <a href = \"#dt-expression\">expression</a>. The content is a\ntemplate.  The expression is evaluated and the resulting object is converted\nto a boolean as if by a call to the <b><a href = \"http://www.w3.org/TR/xpath#function-boolean\">boolean</a></b> function. \nIf the result is true, then the content template is instantiated; otherwise,\nnothing is created. In the following example, the names in a group of names\nare formatted as a comma separated list:</p><pre>&lt;xsl:template match=\"namelist/name\"&gt;\n  &lt;xsl:apply-templates/&gt;\n  &lt;xsl:if test=\"not(position()=last())\"&gt;, &lt;/xsl:if&gt;\n&lt;/xsl:template&gt;</pre><p>The following colors every other table row yellow:</p><pre>&lt;xsl:template match=\"item\"&gt;\n  &lt;tr&gt;\n    &lt;xsl:if test=\"position() mod 2 = 0\"&gt;\n       &lt;xsl:attribute name=\"bgcolor\"&gt;yellow&lt;/xsl:attribute&gt;\n    &lt;/xsl:if&gt;\n    &lt;xsl:apply-templates/&gt;\n  &lt;/tr&gt;\n&lt;/xsl:template&gt;</pre><h3><a name = \"section-Conditional-Processing-with-xsl:choose\" id = \"section-Conditional-Processing-with-xsl:choose\"></a>9.2\nConditional Processing with <code>xsl:choose</code></h3><p class = \"element-syntax\"><a name = \"XSLT_element-choose\" id = \"XSLT_element-choose\"></a><code>&lt;!--\nCategory: instruction --&gt;<br/>\n&lt;xsl:choose&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: (<a href = \"#XSLT_element-when\">xsl:when</a>+, <a href = \"#XSLT_element-otherwise\">xsl:otherwise</a>?) --&gt;<br/>\n&lt;/xsl:choose&gt;</code></p><p class = \"element-syntax\"><a name = \"XSLT_element-when\" id = \"XSLT_element-when\"></a><code>&lt;xsl:when<br/>\n&nbsp;&nbsp;<b>test</b> = <var>boolean-expression</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:when&gt;</code></p><p class = \"element-syntax\"><a name = \"XSLT_element-otherwise\" id = \"XSLT_element-otherwise\"></a><code>&lt;xsl:otherwise&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:otherwise&gt;</code></p><p>The <code>xsl:choose</code> element selects one among a number of possible\nalternatives. It consists of a sequence of <code>xsl:when</code> elements\nfollowed by an optional <code>xsl:otherwise</code> element.  Each\n<code>xsl:when</code> element has a single attribute, <code>test</code>,\nwhich specifies an <a href = \"#dt-expression\">expression</a>. The content of\nthe <code>xsl:when</code> and <code>xsl:otherwise</code> elements is a\ntemplate.  When an <code>xsl:choose</code> element is processed, each of the\n<code>xsl:when</code> elements is tested in turn, by evaluating the\nexpression and converting the resulting object to a boolean as if by a call\nto the <b><a href = \"http://www.w3.org/TR/xpath#function-boolean\">boolean</a></b> function. \nThe content of the first, and only the first, <code>xsl:when</code> element\nwhose test is true is instantiated.  If no <code>xsl:when</code> is true, the\ncontent of the <code>xsl:otherwise</code> element is instantiated. If no\n<code>xsl:when</code> element is true, and no <code>xsl:otherwise</code>\nelement is present, nothing is created.</p><p>The following example enumerates items in an ordered list using arabic\nnumerals, letters, or roman numerals depending on the depth to which the\nordered lists are nested.</p><pre>&lt;xsl:template match=\"orderedlist/listitem\"&gt;\n  &lt;fo:list-item indent-start='2pi'&gt;\n    &lt;fo:list-item-label&gt;\n      &lt;xsl:variable name=\"level\"\n                    select=\"count(ancestor::orderedlist) mod 3\"/&gt;\n      &lt;xsl:choose&gt;\n        &lt;xsl:when test='$level=1'&gt;\n          &lt;xsl:number format=\"i\"/&gt;\n        &lt;/xsl:when&gt;\n        &lt;xsl:when test='$level=2'&gt;\n          &lt;xsl:number format=\"a\"/&gt;\n        &lt;/xsl:when&gt;\n        &lt;xsl:otherwise&gt;\n          &lt;xsl:number format=\"1\"/&gt;\n        &lt;/xsl:otherwise&gt;\n      &lt;/xsl:choose&gt;\n      &lt;xsl:text&gt;. &lt;/xsl:text&gt;\n    &lt;/fo:list-item-label&gt;\n    &lt;fo:list-item-body&gt;\n      &lt;xsl:apply-templates/&gt;\n    &lt;/fo:list-item-body&gt;\n  &lt;/fo:list-item&gt;\n&lt;/xsl:template&gt;</pre><h2><a name = \"sorting\" id = \"sorting\"></a>10 Sorting</h2><p class = \"element-syntax\"><a name = \"XSLT_element-sort\" id = \"XSLT_element-sort\"></a><code>&lt;xsl:sort<br/>\n&nbsp;&nbsp;select = <var>string-expression</var> <br/>\n&nbsp;&nbsp;lang = { <var>nmtoken</var> }<br/>\n&nbsp;&nbsp;data-type = { \"text\" | \"number\" | <var>qname-but-not-ncname</var>\n}<br/>\n&nbsp;&nbsp;order = { \"ascending\" | \"descending\" }<br/>\n&nbsp;&nbsp;case-order = { \"upper-first\" | \"lower-first\"\n}&nbsp;/&gt;</code></p><p>Sorting is specified by adding <code>xsl:sort</code> elements as children\nof an <code>xsl:apply-templates</code> or <code>xsl:for-each</code> element. \nThe first <code>xsl:sort</code> child specifies the primary sort key, the\nsecond <code>xsl:sort</code> child specifies the secondary sort key and so\non.  When an <code>xsl:apply-templates</code> or <code>xsl:for-each</code>\nelement has one or more <code>xsl:sort</code> children, then instead of\nprocessing the selected nodes in document order, it sorts the nodes according\nto the specified sort keys and then processes them in sorted order.  When\nused in <code>xsl:for-each</code>, <code>xsl:sort</code> elements must occur\nfirst.  When a template is instantiated by <code>xsl:apply-templates</code>\nand <code>xsl:for-each</code>, the <a href = \"#dt-current-node-list\">current\nnode list</a> list consists of the complete list of nodes being processed in\nsorted order.</p><p><code>xsl:sort</code> has a <code>select</code> attribute whose value is\nan <a href = \"#dt-expression\">expression</a>. For each node to be processed,\nthe expression is evaluated with that node as the current node and with the\ncomplete list of nodes being processed in unsorted order as the current node\nlist. The resulting object is converted to a string as if by a call to the\n<b><a href = \"http://www.w3.org/TR/xpath#function-string\">string</a></b>\nfunction; this string is used as the sort key for that node. The default\nvalue of the <code>select</code> attribute is <code>.</code>, which will\ncause the string-value of the current node to be used as the sort key.</p><p>This string serves as a sort key for the node.  The following optional\nattributes on <code>xsl:sort</code> control how the list of sort keys are\nsorted; the values of all of these attributes are interpreted as <a href = \"#dt-attribute-value-template\">attribute value templates</a>.</p><ul>\n  <li><p><code>order</code> specifies whether the strings should be sorted in\n    ascending or descending order; <code>ascending</code> specifies ascending\n    order; <code>descending</code> specifies descending order; the default is\n    <code>ascending</code></p>\n  </li>\n  <li><p><code>lang</code> specifies the language of the sort keys; it has\n    the same range of values as <code>xml:lang</code> <a href = \"#XML\">[XML]</a>; if no <code>lang</code> value is specified, the\n    language should be determined from the system environment</p>\n  </li>\n  <li><p><code>data-type</code> specifies the data type of the strings; the\n    following values are allowed:</p>\n    <ul>\n      <li><p><code>text</code> specifies that the sort keys should be sorted\n        lexicographically in the culturally correct manner for the language\n        specified by <code>lang</code></p>\n      </li>\n      <li><p><code>number</code> specifies that the sort keys should be\n        converted to numbers and then sorted according to the numeric value;\n        the sort key is converted to a number as if by a call to the <b><a href = \"http://www.w3.org/TR/xpath#function-number\">number</a></b>\n        function; the <code>lang</code> attribute is ignored</p>\n      </li>\n      <li><p>a <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a> with a\n        prefix is expanded into an <a href = \"http://www.w3.org/TR/xpath#dt-expanded-name\">expanded-name</a>\n        as described in <a href = \"#qname\">[<b>2.4 Qualified Names</b>]</a>;\n        the expanded-name identifies the data-type; the behavior in this case\n        is not specified by this document</p>\n      </li>\n    </ul>\n    <p>The default value is <code>text</code>.</p>\n\n    <blockquote>\n      <b>NOTE:</b>The XSL Working Group plans that future versions of XSLT\n      will leverage XML Schemas to define further values for this\n    attribute.</blockquote>\n  </li>\n  <li><p><code>case-order</code> has the value <code>upper-first</code> or\n    <code>lower-first</code>; this applies when\n    <code>data-type=\"text\"</code>, and specifies that upper-case letters\n    should sort before lower-case letters or vice-versa respectively. For\n    example, if <code>lang=\"en\"</code>, then <code>A a B b</code> are sorted\n    with <code>case-order=\"upper-first\"</code> and <code>a A b B</code> are\n    sorted with <code>case-order=\"lower-first\"</code>. The default value is\n    language dependent.</p>\n  </li>\n</ul><blockquote>\n  <b>NOTE:</b>It is possible for two conforming XSLT processors not to sort\n  exactly the same.  Some XSLT processors may not support some languages. \n  Furthermore, there may be variations possible in the sorting of any\n  particular language that are not specified by the attributes on\n  <code>xsl:sort</code>, for example, whether Hiragana or Katakana is sorted\n  first in Japanese.  Future versions of XSLT may provide additional\n  attributes to provide control over these variations.  Implementations may\n  also use implementation-specific namespaced attributes on\n  <code>xsl:sort</code> for this.</blockquote><blockquote>\n  <b>NOTE:</b>It is recommended that implementers consult <a href = \"#UNICODE-TR10\">[UNICODE TR10]</a> for information on\n  internationalized sorting.</blockquote><p>The sort must be stable: in the sorted list of nodes, any sub list that\nhas sort keys that all compare equal must be in document order.</p><p>For example, suppose an employee database has the form</p><pre>&lt;employees&gt;\n  &lt;employee&gt;\n    &lt;name&gt;\n      &lt;given&gt;James&lt;/given&gt;\n      &lt;family&gt;Clark&lt;/family&gt;\n    &lt;/name&gt;\n    ...\n  &lt;/employee&gt;\n&lt;/employees&gt;</pre><p>Then a list of employees sorted by name could be generated using:</p><pre>&lt;xsl:template match=\"employees\"&gt;\n  &lt;ul&gt;\n    &lt;xsl:apply-templates select=\"employee\"&gt;\n      &lt;xsl:sort select=\"name/family\"/&gt;\n      &lt;xsl:sort select=\"name/given\"/&gt;\n    &lt;/xsl:apply-templates&gt;\n  &lt;/ul&gt;\n&lt;/xsl:template&gt;\n\n&lt;xsl:template match=\"employee\"&gt;\n  &lt;li&gt;\n    &lt;xsl:value-of select=\"name/given\"/&gt;\n    &lt;xsl:text&gt; &lt;/xsl:text&gt;\n    &lt;xsl:value-of select=\"name/family\"/&gt;\n  &lt;/li&gt;\n&lt;/xsl:template&gt;</pre><h2><a name = \"variables\" id = \"variables\"></a>11 Variables and Parameters</h2><p class = \"element-syntax\"><a name = \"XSLT_element-variable\" id = \"XSLT_element-variable\"></a><code>&lt;!--\nCategory: top-level-element --&gt;<br/>\n&lt;!-- Category: instruction --&gt;<br/>\n&lt;xsl:variable<br/>\n&nbsp;&nbsp;<b>name</b> = <var>qname</var> <br/>\n&nbsp;&nbsp;select = <var>expression</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:variable&gt;</code></p><p class = \"element-syntax\"><a name = \"XSLT_element-param\" id = \"XSLT_element-param\"></a><code>&lt;!-- Category:\ntop-level-element --&gt;<br/>\n&lt;xsl:param<br/>\n&nbsp;&nbsp;<b>name</b> = <var>qname</var> <br/>\n&nbsp;&nbsp;select = <var>expression</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:param&gt;</code></p><p>A variable is a name that may be bound to a value.  The value to which a\nvariable is bound (the <b>value</b> of the variable) can be an object of any\nof the types that can be returned by expressions. There are two elements that\ncan be used to bind variables: <code>xsl:variable</code> and\n<code>xsl:param</code>. The difference is that the value specified on the\n<code>xsl:param</code> variable is only a default value for the binding; when\nthe template or stylesheet within which the <code>xsl:param</code> element\noccurs is invoked, parameters may be passed that are used in place of the\ndefault values.</p><p>Both <code>xsl:variable</code> and <code>xsl:param</code> have a required\n<code>name</code> attribute, which specifies the name of the variable.  The\nvalue of the <code>name</code> attribute is a <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a>, which is\nexpanded as described in <a href = \"#qname\">[<b>2.4 Qualified\nNames</b>]</a>.</p><p>For any use of these variable-binding elements, there is a region of the\nstylesheet tree within which the binding is visible; within this region, any\nbinding of the variable that was visible on the variable-binding element\nitself is hidden.  Thus, only the innermost binding of a variable is visible.\n The set of variable bindings in scope for an expression consists of those\nbindings that are visible at the point in the stylesheet where the expression\noccurs.</p><h3><a name = \"section-Result-Tree-Fragments\" id = \"section-Result-Tree-Fragments\"></a>11.1 Result Tree\nFragments</h3><p>Variables introduce an additional data-type into the expression language. \n<a name = \"dt-result-tree-fragment\" id = \"dt-result-tree-fragment\"></a>This additional data type is called\n<b>result tree fragment</b>.  A variable may be bound to a result tree\nfragment instead of one of the four basic XPath data-types (string, number,\nboolean, node-set).  A result tree fragment represents a fragment of the\nresult tree. A result tree fragment is treated equivalently to a node-set\nthat contains just a single root node. However, the operations permitted on a\nresult tree fragment are a subset of those permitted on a node-set.  An\noperation is permitted on a result tree fragment only if that operation would\nbe permitted on a string (the operation on the string may involve first\nconverting the string to a number or boolean). In particular, it is not\npermitted to use the <code>/</code>, <code>//</code>, and <code>[]</code>\noperators on result tree fragments.  When a permitted operation is performed\non a result tree fragment, it is performed exactly as it would be on the\nequivalent node-set.</p><p>When a result tree fragment is copied into the result tree (see <a href = \"#copy-of\">[<b>11.3 Using Values of Variables and Parameters with\n<code>xsl:copy-of</code></b>]</a>), then all the nodes that are children of\nthe root node in the equivalent node-set are added in sequence to the result\ntree.</p><p>Expressions can only return values of type result tree fragment by\nreferencing variables of type result tree fragment or calling extension\nfunctions that return a result tree fragment or getting a system property\nwhose value is a result tree fragment.</p><h3><a name = \"variable-values\" id = \"variable-values\"></a>11.2 Values of Variables and Parameters</h3><p>A variable-binding element can specify the value of the variable in three\nalternative ways.</p><ul>\n  <li><p>If the variable-binding element has a <code>select</code> attribute,\n    then the value of the attribute must be an <a href = \"#dt-expression\">expression</a> and the value of the variable is the\n    object that results from evaluating the expression.  In this case, the\n    content must be empty.</p>\n  </li>\n  <li><p>If the variable-binding element does not have a <code>select</code>\n    attribute and has non-empty content (i.e. the variable-binding element\n    has one or more child nodes), then the content of the variable-binding\n    element specifies the value. The content of the variable-binding element\n    is a template, which is instantiated to give the value of the variable.\n    The value is a result tree fragment equivalent to a node-set containing\n    just a single root node having as children the sequence of nodes produced\n    by instantiating the template. The base URI of the nodes in the result\n    tree fragment is the base URI of the variable-binding element.</p>\n    <p>It is an error if a member of the sequence of nodes created by\n    instantiating the template is an attribute node or a namespace node,\n    since a root node cannot have an attribute node or a namespace node as a\n    child. An XSLT processor may signal the error; if it does not signal the\n    error, it must recover by not adding the attribute node or namespace\n    node.</p>\n  </li>\n  <li><p>If the variable-binding element has empty content and does not have\n    a <code>select</code> attribute, then the value of the variable is an\n    empty string. Thus</p>\n    <pre>&lt;xsl:variable name=\"x\"/&gt;</pre>\n    <p>is equivalent to</p>\n    <pre>&lt;xsl:variable name=\"x\" select=\"''\"/&gt;</pre>\n  </li>\n</ul><blockquote>\n  <b>NOTE:</b>When a variable is used to select nodes by position, be careful\n  not to do:\n  <pre>&lt;xsl:variable name=\"n\"&gt;2&lt;/xsl:variable&gt;\n...\n&lt;xsl:value-of select=\"item[$n]\"/&gt;</pre>\n  This will output the value of the first item element, because the variable\n  <code>n</code> will be bound to a result tree fragment, not a number.\n  Instead, do either\n  <pre>&lt;xsl:variable name=\"n\" select=\"2\"/&gt;\n...\n&lt;xsl:value-of select=\"item[$n]\"/&gt;</pre>\n  or\n  <pre>&lt;xsl:variable name=\"n\"&gt;2&lt;/xsl:variable&gt;\n...\n&lt;xsl:value-of select=\"item[position()=$n]\"/&gt;</pre>\n</blockquote><blockquote>\n  <b>NOTE:</b>One convenient way to specify the empty node-set as the default\n  value of a parameter is:\n  <pre>&lt;xsl:param name=\"x\" select=\"/..\"/&gt;</pre>\n</blockquote><h3><a name = \"copy-of\" id = \"copy-of\"></a>11.3 Using Values of Variables and Parameters with\n<code>xsl:copy-of</code></h3><p class = \"element-syntax\"><a name = \"XSLT_element-copy-of\" id = \"XSLT_element-copy-of\"></a><code>&lt;!--\nCategory: instruction --&gt;<br/>\n&lt;xsl:copy-of<br/>\n&nbsp;&nbsp;<b>select</b> = <var>expression</var>&nbsp;/&gt;</code></p><p>The <code>xsl:copy-of</code> element can be used to insert a result tree\nfragment into the result tree, without first converting it to a string as\n<code>xsl:value-of</code> does (see <a href = \"#value-of\">[<b>7.6.1 Generating\nText with <code>xsl:value-of</code></b>]</a>).  The required\n<code>select</code> attribute contains an <a href = \"#dt-expression\">expression</a>.  When the result of evaluating the\nexpression is a result tree fragment, the complete fragment is copied into\nthe result tree.  When the result is a node-set, all the nodes in the set are\ncopied in document order into the result tree; copying an element node copies\nthe attribute nodes, namespace nodes and children of the element node as well\nas the element node itself; a root node is copied by copying its children.\nWhen the result is neither a node-set nor a result tree fragment, the result\nis converted to a string and then inserted into the result tree, as with\n<code>xsl:value-of</code>.</p><h3><a name = \"top-level-variables\" id = \"top-level-variables\"></a>11.4 Top-level Variables and\nParameters</h3><p>Both <code>xsl:variable</code> and <code>xsl:param</code> are allowed as\n<a href = \"#dt-top-level\">top-level</a> elements. A top-level variable-binding\nelement declares a global variable that is visible everywhere.  A top-level\n<code>xsl:param</code> element declares a parameter to the stylesheet; XSLT\ndoes not define the mechanism by which parameters are passed to the\nstylesheet.  It is an error if a stylesheet contains more than one binding of\na top-level variable with the same name and same <a href = \"#dt-import-precedence\">import precedence</a>. At the top-level, the\nexpression or template specifying the variable value is evaluated with the\nsame context as that used to process the root node of the source document:\nthe current node is the root node of the source document and the current node\nlist is a list containing just the root node of the source document.  If the\ntemplate or expression specifying the value of a global variable <var>x</var>\nreferences a global variable <var>y</var>, then the value for <var>y</var>\nmust be computed before the value of <var>x</var>.  It is an error if it is\nimpossible to do this for all global variable definitions; in other words, it\nis an error if the definitions are circular.</p><p>This example declares a global variable <code>para-font-size</code>, which\nit references in an attribute value template.</p><pre>&lt;xsl:variable name=\"para-font-size\"&gt;12pt&lt;/xsl:variable&gt;\n\n&lt;xsl:template match=\"para\"&gt;\n &lt;fo:block font-size=\"{$para-font-size}\"&gt;\n   &lt;xsl:apply-templates/&gt;\n &lt;/fo:block&gt;\n&lt;/xsl:template&gt;</pre><h3><a name = \"local-variables\" id = \"local-variables\"></a>11.5 Variables and Parameters within\nTemplates</h3><p>As well as being allowed at the top-level, both <code>xsl:variable</code>\nand <code>xsl:param</code> are also allowed in templates. \n<code>xsl:variable</code> is allowed anywhere within a template that an\ninstruction is allowed.  In this case, the binding is visible for all\nfollowing siblings and their descendants. Note that the binding is not\nvisible for the <code>xsl:variable</code> element itself. \n<code>xsl:param</code> is allowed as a child at the beginning of an\n<code>xsl:template</code> element.  In this context, the binding is visible\nfor all following siblings and their descendants.  Note that the binding is\nnot visible for the <code>xsl:param</code> element itself.</p><p><a name = \"dt-shadows\" id = \"dt-shadows\"></a>A binding <b>shadows</b> another binding if the\nbinding occurs at a point where the other binding is visible, and the\nbindings have the same name. It is an error if a binding established by an\n<code>xsl:variable</code> or <code>xsl:param</code> element within a template\n<a href = \"#dt-shadows\">shadows</a> another binding established by an\n<code>xsl:variable</code> or <code>xsl:param</code> element also within the\ntemplate.  It is not an error if a binding established by an\n<code>xsl:variable</code> or <code>xsl:param</code> element in a template <a href = \"#dt-shadows\">shadows</a> another binding established by an\n<code>xsl:variable</code> or <code>xsl:param</code> <a href = \"#dt-top-level\">top-level</a> element.  Thus, the following is an\nerror:</p><pre style = \"color: red\">&lt;xsl:template name=\"foo\"&gt;\n&lt;xsl:param name=\"x\" select=\"1\"/&gt;\n&lt;xsl:variable name=\"x\" select=\"2\"/&gt;\n&lt;/xsl:template&gt;</pre><p>However, the following is allowed:</p><pre>&lt;xsl:param name=\"x\" select=\"1\"/&gt;\n&lt;xsl:template name=\"foo\"&gt;\n&lt;xsl:variable name=\"x\" select=\"2\"/&gt;\n&lt;/xsl:template&gt;</pre><blockquote>\n  <b>NOTE:</b>The nearest equivalent in Java to an <code>xsl:variable</code>\n  element in a template is a final local variable declaration with an\n  initializer.  For example,\n  <pre>&lt;xsl:variable name=\"x\" select=\"'value'\"/&gt;</pre>\n  has similar semantics to\n  <pre>final Object x = \"value\";</pre>\n  XSLT does not provide an equivalent to the Java assignment operator\n  <pre>x = \"value\";</pre>\n  because this would make it harder to create an implementation that\n  processes a document other than in a batch-like way, starting at the\n  beginning and continuing through to the end.</blockquote><h3><a name = \"section-Passing-Parameters-to-Templates\" id = \"section-Passing-Parameters-to-Templates\"></a>11.6 Passing\nParameters to Templates</h3><p class = \"element-syntax\"><a name = \"XSLT_element-with-param\" id = \"XSLT_element-with-param\"></a><code>&lt;xsl:with-param<br/>\n&nbsp;&nbsp;<b>name</b> = <var>qname</var> <br/>\n&nbsp;&nbsp;select = <var>expression</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:with-param&gt;</code></p><p>Parameters are passed to templates using the <code>xsl:with-param</code>\nelement.  The required <code>name</code> attribute specifies the name of the\nparameter (the variable the value of whose binding is to be replaced).  The\nvalue of the <code>name</code> attribute is a <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a>, which is\nexpanded as described in <a href = \"#qname\">[<b>2.4 Qualified Names</b>]</a>. \n<code>xsl:with-param</code> is allowed within both\n<code>xsl:call-template</code> and <code>xsl:apply-templates</code>.  The\nvalue of the parameter is specified in the same way as for\n<code>xsl:variable</code> and <code>xsl:param</code>.  The current node and\ncurrent node list used for computing the value specified by\n<code>xsl:with-param</code> element is the same as that used for the\n<code>xsl:apply-templates</code> or <code>xsl:call-template</code> element\nwithin which it occurs.  It is not an error to pass a parameter <var>x</var>\nto a template that does not have an <code>xsl:param</code> element for\n<var>x</var>; the parameter is simply ignored.</p><p>This example defines a named template for a <code>numbered-block</code>\nwith an argument to control the format of the number.</p><pre>&lt;xsl:template name=\"numbered-block\"&gt;\n  &lt;xsl:param name=\"format\"&gt;1. &lt;/xsl:param&gt;\n  &lt;fo:block&gt;\n    &lt;xsl:number format=\"{$format}\"/&gt;\n    &lt;xsl:apply-templates/&gt;\n  &lt;/fo:block&gt;\n&lt;/xsl:template&gt;\n\n&lt;xsl:template match=\"ol//ol/li\"&gt;\n  &lt;xsl:call-template name=\"numbered-block\"&gt;\n    &lt;xsl:with-param name=\"format\"&gt;a. &lt;/xsl:with-param&gt;\n  &lt;/xsl:call-template&gt;\n&lt;/xsl:template&gt;</pre><h2><a name = \"add-func\" id = \"add-func\"></a>12 Additional Functions</h2><p>This section describes XSLT-specific additions to the core XPath function\nlibrary.  Some of these additional functions also make use of information\nspecified by <a href = \"#dt-top-level\">top-level</a> elements in the\nstylesheet; this section also describes these elements.</p><h3><a name = \"document\" id = \"document\"></a>12.1 Multiple Source Documents</h3><p><a name = \"function-document\" id = \"function-document\"><b>Function: </b><i>node-set</i>\n<b>document</b>(<i>object</i>, <i>node-set</i>?)</a></p><p>The <b><a href = \"#function-document\">document</a></b> function allows\naccess to XML documents other than the main source document.</p><p>When the <b><a href = \"#function-document\">document</a></b> function has\nexactly one argument and the argument is a node-set, then the result is the\nunion, for each node in the argument node-set, of the result of calling the\n<b><a href = \"#function-document\">document</a></b> function with the first\nargument being the <a href = \"http://www.w3.org/TR/xpath#dt-string-value\">string-value</a> of the\nnode, and the second argument being a node-set with the node as its only\nmember. When the <b><a href = \"#function-document\">document</a></b> function\nhas two arguments and the first argument is a node-set, then the result is\nthe union, for each node in the argument node-set, of the result of calling\nthe <b><a href = \"#function-document\">document</a></b> function with the first\nargument being the <a href = \"http://www.w3.org/TR/xpath#dt-string-value\">string-value</a> of the\nnode, and with the second argument being the second argument passed to the\n<b><a href = \"#function-document\">document</a></b> function.</p><p>When the first argument to the <b><a href = \"#function-document\">document</a></b> function is not a node-set, the\nfirst argument is converted to a string as if by a call to the <b><a href = \"http://www.w3.org/TR/xpath#function-string\">string</a></b> function.\nThis string is treated as a URI reference; the resource identified by the URI\nis retrieved. The data resulting from the retrieval action is parsed as an\nXML document and a tree is constructed in accordance with the data model (see\n<a href = \"#data-model\">[<b>3 Data Model</b>]</a>).  If there is an error\nretrieving the resource, then the XSLT processor may signal an error; if it\ndoes not signal an error, it must recover by returning an empty node-set. \nOne possible kind of retrieval error is that the XSLT processor does not\nsupport the URI scheme used by the URI.  An XSLT processor is not required to\nsupport any particular URI schemes.  The documentation for an XSLT processor\nshould specify which URI schemes the XSLT processor supports.</p><p>If the URI reference does not contain a fragment identifier, then a\nnode-set containing just the root node of the document is returned. If the\nURI reference does contain a fragment identifier, the function returns a\nnode-set containing the nodes in the tree identified by the fragment\nidentifier of the URI reference. The semantics of the fragment identifier is\ndependent on the media type of the result of retrieving the URI.  If there is\nan error in processing the fragment identifier, the XSLT processor may signal\nthe error; if it does not signal the error, it must recover by returning an\nempty node-set. Possible errors include:</p><ul>\n  <li><p>The fragment identifier identifies something that cannot be\n    represented by an XSLT node-set (such as a range of characters within a\n    text node).</p>\n  </li>\n  <li><p>The XSLT processor does not support fragment identifiers for the\n    media-type of the retrieval result.  An XSLT processor is not required to\n    support any particular media types.  The documentation for an XSLT\n    processor should specify for which media types the XSLT processor\n    supports fragment identifiers.</p>\n  </li>\n</ul><p>The data resulting from the retrieval action is parsed as an XML document\nregardless of the media type of the retrieval result; if the top-level media\ntype is <code>text</code>, then it is parsed in the same way as if the media\ntype were <code>text/xml</code>; otherwise, it is parsed in the same way as\nif the media type were <code>application/xml</code>.</p><blockquote>\n  <b>NOTE:</b>Since there is no top-level <code>xml</code> media type, data\n  with a media type other than <code>text/xml</code> or\n  <code>application/xml</code> may in fact be XML.</blockquote><p>The URI reference may be relative. The base URI (see <a href = \"#base-uri\">[<b>3.2 Base URI</b>]</a>) of the node in the second\nargument node-set that is first in document order is used as the base URI for\nresolving the relative URI into an absolute URI.  If the second argument is\nomitted, then it defaults to the node in the stylesheet that contains the\nexpression that includes the call to the <b><a href = \"#function-document\">document</a></b> function.  Note that a zero-length\nURI reference is a reference to the document relative to which the URI\nreference is being resolved; thus <code>document(\"\")</code> refers to the\nroot node of the stylesheet; the tree representation of the stylesheet is\nexactly the same as if the XML document containing the stylesheet was the\ninitial source document.</p><p>Two documents are treated as the same document if they are identified by\nthe same URI. The URI used for the comparison is the absolute URI into which\nany relative URI was resolved and does not include any fragment identifier. \nOne root node is treated as the same node as another root node if the two\nnodes are from the same document. Thus, the following expression will always\nbe true:</p><pre>generate-id(document(\"foo.xml\"))=generate-id(document(\"foo.xml\"))</pre><p>The <b><a href = \"#function-document\">document</a></b> function gives rise\nto the possibility that a node-set may contain nodes from more than one\ndocument.  With such a node-set, the relative document order of two nodes in\nthe same document is the normal <a href = \"http://www.w3.org/TR/xpath#dt-document-order\">document order</a>\ndefined by XPath <a href = \"#XPATH\">[XPath]</a>.  The relative document order\nof two nodes in different documents is determined by an\nimplementation-dependent ordering of the documents containing the two nodes. \nThere are no constraints on how the implementation orders documents other\nthan that it must do so consistently: an implementation must always use the\nsame order for the same set of documents.</p><h3><a name = \"key\" id = \"key\"></a>12.2 Keys</h3><p>Keys provide a way to work with documents that contain an implicit\ncross-reference structure.  The <code>ID</code>, <code>IDREF</code> and\n<code>IDREFS</code> attribute types in XML provide a mechanism to allow XML\ndocuments to make their cross-reference explicit.  XSLT supports this through\nthe XPath <b><a href = \"http://www.w3.org/TR/xpath#function-id\">id</a></b>\nfunction. However, this mechanism has a number of limitations:</p><ul>\n  <li><p>ID attributes must be declared as such in the DTD.  If an ID\n    attribute is declared as an ID attribute only in the external DTD subset,\n    then it will be recognized as an ID attribute only if the XML processor\n    reads the external DTD subset.  However, XML does not require XML\n    processors to read the external DTD, and they may well choose not to do\n    so, especially if the document is declared\n    <code>standalone=\"yes\"</code>.</p>\n  </li>\n  <li><p>A document can contain only a single set of unique IDs. There cannot\n    be separate independent sets of unique IDs.</p>\n  </li>\n  <li><p>The ID of an element can only be specified in an attribute; it\n    cannot be specified by the content of the element, or by a child\n    element.</p>\n  </li>\n  <li><p>An ID is constrained to be an XML name.  For example, it cannot\n    contain spaces.</p>\n  </li>\n  <li><p>An element can have at most one ID.</p>\n  </li>\n  <li><p>At most one element can have a particular ID.</p>\n  </li>\n</ul><p>Because of these limitations XML documents sometimes contain a\ncross-reference structure that is not explicitly declared by ID/IDREF/IDREFS\nattributes.</p><p>A key is a triple containing:</p><ol>\n  <li><p>the node which has the key</p>\n  </li>\n  <li><p>the name of the key (an <a href = \"http://www.w3.org/TR/xpath#dt-expanded-name\">expanded-name</a>)</p>\n  </li>\n  <li><p>the value of the key (a string)</p>\n  </li>\n</ol><p>A stylesheet declares a set of keys for each document using the\n<code>xsl:key</code> element.  When this set of keys contains a member with\nnode <var>x</var>, name <var>y</var> and value <var>z</var>, we say that node\n<var>x</var> has a key with name <var>y</var> and value <var>z</var>.</p><p>Thus, a key is a kind of generalized ID, which is not subject to the same\nlimitations as an XML ID:</p><ul>\n  <li><p>Keys are declared in the stylesheet using <code>xsl:key</code>\n    elements.</p>\n  </li>\n  <li><p>A key has a name as well as a value; each key name may be thought of\n    as distinguishing a separate, independent space of identifiers.</p>\n  </li>\n  <li><p>The value of a named key for an element may be specified in any\n    convenient place; for example, in an attribute, in a child element or in\n    content.  An XPath expression is used to specify where to find the value\n    for a particular named key.</p>\n  </li>\n  <li><p>The value of a key can be an arbitrary string; it is not constrained\n    to be a name.</p>\n  </li>\n  <li><p>There can be multiple keys in a document with the same node, same\n    key name, but different key values.</p>\n  </li>\n  <li><p>There can be multiple keys in a document with the same key name,\n    same key value, but different nodes.</p>\n  </li>\n</ul><p class = \"element-syntax\"><a name = \"XSLT_element-key\" id = \"XSLT_element-key\"></a><code>&lt;!-- Category:\ntop-level-element --&gt;<br/>\n&lt;xsl:key<br/>\n&nbsp;&nbsp;<b>name</b> = <var>qname</var> <br/>\n&nbsp;&nbsp;<b>match</b> = <var>pattern</var> <br/>\n&nbsp;&nbsp;<b>use</b> = <var>expression</var>&nbsp;/&gt;</code></p><p>The <code>xsl:key</code> element is used to declare keys.  The\n<code>name</code> attribute specifies the name of the key.  The value of the\n<code>name</code> attribute is a <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a>, which is\nexpanded as described in <a href = \"#qname\">[<b>2.4 Qualified Names</b>]</a>.\nThe <code>match</code> attribute is a <a href = \"#NT-Pattern\">Pattern</a>; an\n<code>xsl:key</code> element gives information about the keys of any node\nthat matches the pattern specified in the match attribute.  The\n<code>use</code> attribute is an <a href = \"#dt-expression\">expression</a>\nspecifying the values of the key; the expression is evaluated once for each\nnode that matches the pattern.  If the result is a node-set, then for each\nnode in the node-set, the node that matches the pattern has a key of the\nspecified name whose value is the string-value of the node in the node-set;\notherwise, the result is converted to a string, and the node that matches the\npattern has a key of the specified name with value equal to that string. \nThus, a node <var>x</var> has a key with name <var>y</var> and value\n<var>z</var> if and only if there is an <code>xsl:key</code> element such\nthat:</p><ul>\n  <li><p><var>x</var> matches the pattern specified in the <code>match</code>\n    attribute of the <code>xsl:key</code> element;</p>\n  </li>\n  <li><p>the value of the <code>name</code> attribute of the\n    <code>xsl:key</code> element is equal to <var>y</var>; and</p>\n  </li>\n  <li><p>when the expression specified in the <code>use</code> attribute of\n    the <code>xsl:key</code> element is evaluated with <var>x</var> as the\n    current node and with a node list containing just <var>x</var> as the\n    current node list resulting in an object <var>u</var>, then either\n    <var>z</var> is equal to the result of converting <var>u</var> to a\n    string as if by a call to the <b><a href = \"http://www.w3.org/TR/xpath#function-string\">string</a></b>\n    function, or <var>u</var> is a node-set and <var>z</var> is equal to the\n    string-value of one or more of the nodes in <var>u</var>.</p>\n  </li>\n</ul><p>Note also that there may be more than one <code>xsl:key</code> element\nthat matches a given node; all of the matching <code>xsl:key</code> elements\nare used, even if they do not have the same <a href = \"#dt-import-precedence\">import precedence</a>.</p><p>It is an error for the value of either the <code>use</code> attribute or\nthe <code>match</code> attribute to contain a <a href = \"http://www.w3.org/TR/xpath#NT-VariableReference\">VariableReference</a>.</p><p><a name = \"function-key\" id = \"function-key\"><b>Function: </b><i>node-set</i>\n<b>key</b>(<i>string</i>, <i>object</i>)</a></p><p>The <b><a href = \"#function-key\">key</a></b> function does for keys what the\n<b><a href = \"http://www.w3.org/TR/xpath#function-id\">id</a></b> function does\nfor IDs.  The first argument specifies the name of the key. The value of the\nargument must be a <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a>, which is\nexpanded as described in <a href = \"#qname\">[<b>2.4 Qualified Names</b>]</a>.\nWhen the second argument to the <b><a href = \"#function-key\">key</a></b>\nfunction is of type node-set, then the result is the union of the result of\napplying the <b><a href = \"#function-key\">key</a></b> function to the string <a href = \"http://www.w3.org/TR/xpath#dt-value\">value</a> of each of the nodes in\nthe argument node-set.  When the second argument to <b><a href = \"#function-key\">key</a></b> is of any other type, the argument is\nconverted to a string as if by a call to the <b><a href = \"http://www.w3.org/TR/xpath#function-string\">string</a></b> function; it\nreturns a node-set containing the nodes in the same document as the context\nnode that have a value for the named key equal to this string.</p><p>For example, given a declaration</p><pre>&lt;xsl:key name=\"idkey\" match=\"div\" use=\"@id\"/&gt;</pre><p>an expression <code>key(\"idkey\",@ref)</code> will return the same node-set\nas <code>id(@ref)</code>, assuming that the only ID attribute declared in the\nXML source document is:</p><pre>&lt;!ATTLIST div id ID #IMPLIED&gt;</pre><p>and that the <code>ref</code> attribute of the current node contains no\nwhitespace.</p><p>Suppose a document describing a function library uses a\n<code>prototype</code> element to define functions</p><pre>&lt;prototype name=\"key\" return-type=\"node-set\"&gt;\n&lt;arg type=\"string\"/&gt;\n&lt;arg type=\"object\"/&gt;\n&lt;/prototype&gt;</pre><p>and a <code>function</code> element to refer to function names</p><pre>&lt;function&gt;key&lt;/function&gt;</pre><p>Then the stylesheet could generate hyperlinks between the references and\ndefinitions as follows:</p><pre>&lt;xsl:key name=\"func\" match=\"prototype\" use=\"@name\"/&gt;\n\n&lt;xsl:template match=\"function\"&gt;\n&lt;b&gt;\n  &lt;a href=\"#{generate-id(key('func',.))}\"&gt;\n    &lt;xsl:apply-templates/&gt;\n  &lt;/a&gt;\n&lt;/b&gt;\n&lt;/xsl:template&gt;\n\n&lt;xsl:template match=\"prototype\"&gt;\n&lt;p&gt;&lt;a name=\"{generate-id()}\"&gt;\n&lt;b&gt;Function: &lt;/b&gt;\n...\n&lt;/a&gt;&lt;/p&gt;\n&lt;/xsl:template&gt;</pre><p>The <b><a href = \"#function-key\">key</a></b> can be used to retrieve a key\nfrom a document other than the document containing the context node.  For\nexample, suppose a document contains bibliographic references in the form\n<code>&lt;bibref&gt;XSLT&lt;/bibref&gt;</code>, and there is a separate XML\ndocument <code>bib.xml</code> containing a bibliographic database with\nentries in the form:</p><pre>&lt;entry name=\"XSLT\"&gt;...&lt;/entry&gt;</pre><p>Then the stylesheet could use the following to transform the\n<code>bibref</code> elements:</p><pre>&lt;xsl:key name=\"bib\" match=\"entry\" use=\"@name\"/&gt;\n\n&lt;xsl:template match=\"bibref\"&gt;\n  &lt;xsl:variable name=\"name\" select=\".\"/&gt;\n  &lt;xsl:for-each select=\"document('bib.xml')\"&gt;\n    &lt;xsl:apply-templates select=\"key('bib',$name)\"/&gt;\n  &lt;/xsl:for-each&gt;\n&lt;/xsl:template&gt;</pre><h3><a name = \"format-number\" id = \"format-number\"></a>12.3 Number Formatting</h3><p><a name = \"function-format-number\" id = \"function-format-number\"><b>Function: </b><i>string</i>\n<b>format-number</b>(<i>number</i>, <i>string</i>, <i>string</i>?)</a></p><p>The <b><a href = \"#function-format-number\">format-number</a></b> function\nconverts its first argument to a string using the format pattern string\nspecified by the second argument and the decimal-format named by the third\nargument, or the default decimal-format, if there is no third argument.  The\nformat pattern string is in the syntax specified by the JDK 1.1 <a href = \"http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormat.html\">DecimalFormat</a>\nclass. The format pattern string is in a localized notation: the\ndecimal-format determines what characters have a special meaning in the\npattern (with the exception of the quote character, which is not localized). \nThe format pattern must not contain the currency sign (#x00A4); support for\nthis feature was added after the initial release of JDK 1.1.  The\ndecimal-format name must be a <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a>, which is\nexpanded as described in <a href = \"#qname\">[<b>2.4 Qualified Names</b>]</a>. \nIt is an error if the stylesheet does not contain a declaration of the\ndecimal-format with the specified <a href = \"http://www.w3.org/TR/xpath#dt-expanded-name\">expanded-name</a>.</p><blockquote>\n  <b>NOTE:</b>Implementations are not required to use the JDK 1.1\n  implementation, nor are implementations required to be implemented in\nJava.</blockquote><blockquote>\n  <b>NOTE:</b>Stylesheets can use other facilities in XPath to control\n  rounding.</blockquote><p class = \"element-syntax\"><a name = \"XSLT_element-decimal-format\" id = \"XSLT_element-decimal-format\"></a><code>&lt;!--\nCategory: top-level-element --&gt;<br/>\n&lt;xsl:decimal-format<br/>\n&nbsp;&nbsp;name = <var>qname</var> <br/>\n&nbsp;&nbsp;decimal-separator = <var>char</var> <br/>\n&nbsp;&nbsp;grouping-separator = <var>char</var> <br/>\n&nbsp;&nbsp;infinity = <var>string</var> <br/>\n&nbsp;&nbsp;minus-sign = <var>char</var> <br/>\n&nbsp;&nbsp;NaN = <var>string</var> <br/>\n&nbsp;&nbsp;percent = <var>char</var> <br/>\n&nbsp;&nbsp;per-mille = <var>char</var> <br/>\n&nbsp;&nbsp;zero-digit = <var>char</var> <br/>\n&nbsp;&nbsp;digit = <var>char</var> <br/>\n&nbsp;&nbsp;pattern-separator = <var>char</var>&nbsp;/&gt;</code></p><p>The <code>xsl:decimal-format</code> element declares a decimal-format,\nwhich controls the interpretation of a format pattern used by the <b><a href = \"#function-format-number\">format-number</a></b> function.  If there is a\n<code>name</code> attribute, then the element declares a named\ndecimal-format; otherwise, it declares the default decimal-format. The value\nof the <code>name</code> attribute is a <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a>, which is\nexpanded as described in <a href = \"#qname\">[<b>2.4 Qualified Names</b>]</a>. \nIt is an error to declare either the default decimal-format or a\ndecimal-format with a given name more than once (even with different <a href = \"#dt-import-precedence\">import precedence</a>), unless it is declared\nevery time with the same value for all attributes (taking into account any\ndefault values).</p><p>The other attributes on <code>xsl:decimal-format</code> correspond to the\nmethods on the JDK 1.1 <a href = \"http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormatSymbols.html\">DecimalFormatSymbols</a>\nclass.  For each <code>get</code>/<code>set</code> method pair there is an\nattribute defined for the <code>xsl:decimal-format</code> element.</p><p>The following attributes both control the interpretation of characters in\nthe format pattern and specify characters that may appear in the result of\nformatting the number:</p><ul>\n  <li><p><code>decimal-separator</code> specifies the character used for the\n    decimal sign; the default value is the period character\n    (<code>.</code>)</p>\n  </li>\n  <li><p><code>grouping-separator</code> specifies the character used as a\n    grouping (e.g. thousands) separator; the default value is the comma\n    character (<code>,</code>)</p>\n  </li>\n  <li><p><code>percent</code> specifies the character used as a percent sign;\n    the default value is the percent character (<code><undefined></undefined></code>)</p>\n  </li>\n  <li><p><code>per-mille</code> specifies the character used as a per mille\n    sign; the default value is the Unicode per-mille character (#x2030)</p>\n  </li>\n  <li><p><code>zero-digit</code> specifies the character used as the digit\n    zero; the default value is the digit zero (<code>0</code>)</p>\n  </li>\n</ul><p>The following attributes control the interpretation of characters in the\nformat pattern:</p><ul>\n  <li><p><code>digit</code> specifies the character used for a digit in the\n    format pattern; the default value is the number sign character\n    (<code>#</code>)</p>\n  </li>\n  <li><p><code>pattern-separator</code> specifies the character used to\n    separate positive and negative sub patterns in a pattern; the default\n    value is the semi-colon character (<code>;</code>)</p>\n  </li>\n</ul><p>The following attributes specify characters or strings that may appear in\nthe result of formatting the number:</p><ul>\n  <li><p><code>infinity</code> specifies the string used to represent\n    infinity; the default value is the string <code>Infinity</code></p>\n  </li>\n  <li><p><code>NaN</code> specifies the string used to represent the NaN\n    value; the default value is the string <code>NaN</code></p>\n  </li>\n  <li><p><code>minus-sign</code> specifies the character used as the default\n    minus sign; the default value is the hyphen-minus character\n    (<code>-</code>, #x2D)</p>\n  </li>\n</ul><h3><a name = \"misc-func\" id = \"misc-func\"></a>12.4 Miscellaneous Additional Functions</h3><p><a name = \"function-current\" id = \"function-current\"><b>Function: </b><i>node-set</i>\n<b>current</b>()</a></p><p>The <b><a href = \"#function-current\">current</a></b> function returns a\nnode-set that has the <a href = \"#dt-current-node\">current node</a> as its only\nmember.  For an outermost expression (an expression not occurring within\nanother expression), the current node is always the same as the context node.\n Thus,</p><pre>&lt;xsl:value-of select=\"current()\"/&gt;</pre><p>means the same as</p><pre>&lt;xsl:value-of select=\".\"/&gt;</pre><p>However, within square brackets the current node is usually different from\nthe context node. For example,</p><pre>&lt;xsl:apply-templates select=\"//glossary/item[@name=current()/@ref]\"/&gt;</pre><p>will process all <code>item</code> elements that have a\n<code>glossary</code> parent element and that have a <code>name</code>\nattribute with value equal to the value of the current node's\n<code>ref</code> attribute. This is different from</p><pre>&lt;xsl:apply-templates select=\"//glossary/item[@name=./@ref]\"/&gt;</pre><p>which means the same as</p><pre>&lt;xsl:apply-templates select=\"//glossary/item[@name=@ref]\"/&gt;</pre><p>and so would process all <code>item</code> elements that have a\n<code>glossary</code> parent element and that have a <code>name</code>\nattribute and a <code>ref</code> attribute with the same value.</p><p>It is an error to use the <b><a href = \"#function-current\">current</a></b>\nfunction in a <a href = \"#dt-pattern\">pattern</a>.</p><p><a name = \"function-unparsed-entity-uri\" id = \"function-unparsed-entity-uri\"><b>Function: </b><i>string</i>\n<b>unparsed-entity-uri</b>(<i>string</i>)</a></p><p>The <b><a href = \"#function-unparsed-entity-uri\">unparsed-entity-uri</a></b>\nreturns the URI of the unparsed entity with the specified name in the same\ndocument as the context node (see <a href = \"#unparsed-entities\">[<b>3.3\nUnparsed Entities</b>]</a>).  It returns the empty string if there is no such\nentity.</p><p><a name = \"function-generate-id\" id = \"function-generate-id\"><b>Function: </b><i>string</i>\n<b>generate-id</b>(<i>node-set</i>?)</a></p><p>The <b><a href = \"#function-generate-id\">generate-id</a></b> function\nreturns a string that uniquely identifies the node in the argument node-set\nthat is first in document order.  The unique identifier must consist of ASCII\nalphanumeric characters and must start with an alphabetic character. Thus,\nthe string is syntactically an XML name.  An implementation is free to\ngenerate an identifier in any convenient way provided that it always\ngenerates the same identifier for the same node and that different\nidentifiers are always generated from different nodes. An implementation is\nunder no obligation to generate the same identifiers each time a document is\ntransformed.  There is no guarantee that a generated unique identifier will\nbe distinct from any unique IDs specified in the source document.  If the\nargument node-set is empty, the empty string is returned. If the argument is\nomitted, it defaults to the context node.</p><p><a name = \"function-system-property\" id = \"function-system-property\"><b>Function: </b><i>object</i>\n<b>system-property</b>(<i>string</i>)</a></p><p>The argument must evaluate to a string that is a <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a>.  The <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a> is expanded into\na name using the namespace declarations in scope for the expression. The\n<b><a href = \"#function-system-property\">system-property</a></b> function\nreturns an object representing the value of the system property identified by\nthe name. If there is no such system property, the empty string should be\nreturned.</p><p>Implementations must provide the following system properties, which are\nall in the XSLT namespace:</p><ul>\n  <li><code>xsl:version</code>, a number giving the version of XSLT\n    implemented by the processor; for XSLT processors implementing the\n    version of XSLT specified by this document, this is the number 1.0</li>\n  <li><code>xsl:vendor</code>, a string identifying the vendor of the XSLT\n    processor</li>\n  <li><code>xsl:vendor-url</code>, a string containing a URL identifying the\n    vendor of the XSLT processor; typically this is the host page (home page)\n    of the vendor's Web site.</li>\n</ul><h2><a name = \"message\" id = \"message\"></a>13 Messages</h2><p class = \"element-syntax\"><a name = \"XSLT_element-message\" id = \"XSLT_element-message\"></a><code>&lt;!--\nCategory: instruction --&gt;<br/>\n&lt;xsl:message<br/>\n&nbsp;&nbsp;terminate = \"yes\" | \"no\"&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:message&gt;</code></p><p>The <code>xsl:message</code> instruction sends a message in a way that is\ndependent on the XSLT processor.  The content of the <code>xsl:message</code>\ninstruction is a template.  The <code>xsl:message</code> is instantiated by\ninstantiating the content to create an XML fragment.  This XML fragment is\nthe content of the message.</p><blockquote>\n  <b>NOTE:</b>An XSLT processor might implement <code>xsl:message</code> by\n  popping up an alert box or by writing to a log file.</blockquote><p>If the <code>terminate</code> attribute has the value <code>yes</code>,\nthen the XSLT processor should terminate processing after sending the\nmessage.  The default value is <code>no</code>.</p><p>One convenient way to do localization is to put the localized information\n(message text, etc.) in an XML document, which becomes an additional input\nfile to the stylesheet.  For example, suppose messages for a language\n<code><var>L</var></code> are stored in an XML file\n<code>resources/<var>L</var>.xml</code> in the form:</p><pre>&lt;messages&gt;\n  &lt;message name=\"problem\"&gt;A problem was detected.&lt;/message&gt;\n  &lt;message name=\"error\"&gt;An error was detected.&lt;/message&gt;\n&lt;/messages&gt;</pre><p>Then a stylesheet could use the following approach to localize\nmessages:</p><pre>&lt;xsl:param name=\"lang\" select=\"en\"/&gt;\n&lt;xsl:variable name=\"messages\"\n  select=\"document(concat('resources/', $lang, '.xml'))/messages\"/&gt;\n\n&lt;xsl:template name=\"localized-message\"&gt;\n  &lt;xsl:param name=\"name\"/&gt;\n  &lt;xsl:message&gt;\n    &lt;xsl:value-of select=\"$messages/message[@name=$name]\"/&gt;\n  &lt;/xsl:message&gt;\n&lt;/xsl:template&gt;\n\n&lt;xsl:template name=\"problem\"&gt;\n  &lt;xsl:call-template name=\"localized-message\"/&gt;\n    &lt;xsl:with-param name=\"name\"&gt;problem&lt;/xsl:with-param&gt;\n  &lt;/xsl:call-template&gt;\n&lt;/xsl:template&gt;</pre><h2><a name = \"extension\" id = \"extension\"></a>14 Extensions</h2><p>XSLT allows two kinds of extension, extension elements and extension\nfunctions.</p><p>This version of XSLT does not provide a mechanism for defining\nimplementations of extensions.  Therefore, an XSLT stylesheet that must be\nportable between XSLT implementations cannot rely on particular extensions\nbeing available.  XSLT provides mechanisms that allow an XSLT stylesheet to\ndetermine whether the XSLT processor by which it is being processed has\nimplementations of particular extensions available, and to specify what\nshould happen if those extensions are not available.  If an XSLT stylesheet\nis careful to make use of these mechanisms, it is possible for it to take\nadvantage of extensions and still work with any XSLT implementation.</p><h3><a name = \"extension-element\" id = \"extension-element\"></a>14.1 Extension Elements</h3><p><a name = \"dt-extension-namespace\" id = \"dt-extension-namespace\"></a>The element extension mechanism\nallows namespaces to be designated as <b>extension namespace</b>s. When a\nnamespace is designated as an extension namespace and an element with a name\nfrom that namespace occurs in a template, then the element is treated as an\ninstruction rather than as a literal result element. The namespace determines\nthe semantics of the instruction.</p><blockquote>\n  <b>NOTE:</b>Since an element that is a child of an\n  <code>xsl:stylesheet</code> element is not occurring <i>in a template</i>,\n  non-XSLT <a href = \"#dt-top-level\">top-level</a> elements are not extension\n  elements as defined here, and nothing in this section applies to\nthem.</blockquote><p>A namespace is designated as an extension namespace by using an\n<code>extension-element-prefixes</code> attribute on an\n<code>xsl:stylesheet</code> element or an\n<code>xsl:extension-element-prefixes</code> attribute on a literal result\nelement or extension element. The value of both these attributes is a\nwhitespace-separated list of namespace prefixes. The namespace bound to each\nof the prefixes is designated as an extension namespace.  It is an error if\nthere is no namespace bound to the prefix on the element bearing the\n<code>extension-element-prefixes</code> or\n<code>xsl:extension-element-prefixes</code> attribute.  The default namespace\n(as declared by <code>xmlns</code>) may be designated as an extension\nnamespace by including <code>#default</code> in the list of namespace\nprefixes.  The designation of a namespace as an extension namespace is\neffective within the subtree of the stylesheet rooted at the element bearing\nthe <code>extension-element-prefixes</code> or\n<code>xsl:extension-element-prefixes</code> attribute; a subtree rooted at an\n<code>xsl:stylesheet</code> element does not include any stylesheets imported\nor included by children of that <code>xsl:stylesheet</code> element.</p><p>If the XSLT processor does not have an implementation of a particular\nextension element available, then the <b><a href = \"#function-element-available\">element-available</a></b> function must\nreturn false for the name of the element.  When such an extension element is\ninstantiated, then the XSLT processor must perform fallback for the element\nas specified in <a href = \"#fallback\">[<b>15 Fallback</b>]</a>.  An XSLT\nprocessor must not signal an error merely because a template contains an\nextension element for which no implementation is available.</p><p>If the XSLT processor has an implementation of a particular extension\nelement available, then the <b><a href = \"#function-element-available\">element-available</a></b> function must\nreturn true for the name of the element.</p><h3><a name = \"section-Extension-Functions\" id = \"section-Extension-Functions\"></a>14.2 Extension Functions</h3><p>If a <a href = \"http://www.w3.org/TR/xpath#NT-FunctionName\">FunctionName</a>\nin a <a href = \"http://www.w3.org/TR/xpath#NT-FunctionCall\">FunctionCall</a>\nexpression is not an <a href = \"http://www.w3.org/TR/REC-xml-names#NT-NCName\">NCName</a> (i.e. if it\ncontains a colon), then it is treated as a call to an extension function. \nThe <a href = \"http://www.w3.org/TR/xpath#NT-FunctionName\">FunctionName</a> is\nexpanded to a name using the namespace declarations from the evaluation\ncontext.</p><p>If the XSLT processor does not have an implementation of an extension\nfunction of a particular name available, then the <b><a href = \"#function-function-available\">function-available</a></b> function must\nreturn false for that name.  If such an extension function occurs in an\nexpression and the extension function is actually called, the XSLT processor\nmust signal an error.  An XSLT processor must not signal an error merely\nbecause an expression contains an extension function for which no\nimplementation is available.</p><p>If the XSLT processor has an implementation of an extension function of a\nparticular name available, then the <b><a href = \"#function-function-available\">function-available</a></b> function must\nreturn true for that name. If such an extension is called, then the XSLT\nprocessor must call the implementation passing it the function call\narguments; the result returned by the implementation is returned as the\nresult of the function call.</p><h2><a name = \"fallback\" id = \"fallback\"></a>15 Fallback</h2><p class = \"element-syntax\"><a name = \"XSLT_element-fallback\" id = \"XSLT_element-fallback\"></a><code>&lt;!--\nCategory: instruction --&gt;<br/>\n&lt;xsl:fallback&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:fallback&gt;</code></p><p>Normally, instantiating an <code>xsl:fallback</code> element does nothing.\n However, when an XSLT processor performs fallback for an instruction\nelement, if the instruction element has one or more <code>xsl:fallback</code>\nchildren, then the content of each of the <code>xsl:fallback</code> children\nmust be instantiated in sequence; otherwise, an error must be signaled. The\ncontent of an <code>xsl:fallback</code> element is a template.</p><p>The following functions can be used with the <code>xsl:choose</code> and\n<code>xsl:if</code> instructions to explicitly control how a stylesheet\nshould behave if particular elements or functions are not available.</p><p><a name = \"function-element-available\" id = \"function-element-available\"><b>Function: </b><i>boolean</i>\n<b>element-available</b>(<i>string</i>)</a></p><p>The argument must evaluate to a string that is a <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a>.  The <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a> is expanded into\nan <a href = \"http://www.w3.org/TR/xpath#dt-expanded-name\">expanded-name</a>\nusing the namespace declarations in scope for the expression. The <b><a href = \"#function-element-available\">element-available</a></b> function returns\ntrue if and only if the expanded-name is the name of an instruction.  If the\nexpanded-name has a namespace URI equal to the XSLT namespace URI, then it\nrefers to an element defined by XSLT.  Otherwise, it refers to an extension\nelement. If the expanded-name has a null namespace URI, the <b><a href = \"#function-element-available\">element-available</a></b> function will\nreturn false.</p><p><a name = \"function-function-available\" id = \"function-function-available\"><b>Function: </b><i>boolean</i>\n<b>function-available</b>(<i>string</i>)</a></p><p>The argument must evaluate to a string that is a <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a>.  The <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a> is expanded into\nan <a href = \"http://www.w3.org/TR/xpath#dt-expanded-name\">expanded-name</a>\nusing the namespace declarations in scope for the expression. The <b><a href = \"#function-function-available\">function-available</a></b> function\nreturns true if and only if the expanded-name is the name of a function in\nthe function library. If the expanded-name has a non-null namespace URI, then\nit refers to an extension function; otherwise, it refers to a function\ndefined by XPath or XSLT.</p><h2><a name = \"output\" id = \"output\"></a>16 Output</h2><p class = \"element-syntax\"><a name = \"XSLT_element-output\" id = \"XSLT_element-output\"></a><code>&lt;!--\nCategory: top-level-element --&gt;<br/>\n&lt;xsl:output<br/>\n&nbsp;&nbsp;method = \"xml\" | \"html\" | \"text\" |\n<var>qname-but-not-ncname</var> <br/>\n&nbsp;&nbsp;version = <var>nmtoken</var> <br/>\n&nbsp;&nbsp;encoding = <var>string</var> <br/>\n&nbsp;&nbsp;omit-xml-declaration = \"yes\" | \"no\"<br/>\n&nbsp;&nbsp;standalone = \"yes\" | \"no\"<br/>\n&nbsp;&nbsp;doctype-public = <var>string</var> <br/>\n&nbsp;&nbsp;doctype-system = <var>string</var> <br/>\n&nbsp;&nbsp;cdata-section-elements = <var>qnames</var> <br/>\n&nbsp;&nbsp;indent = \"yes\" | \"no\"<br/>\n&nbsp;&nbsp;media-type = <var>string</var>&nbsp;/&gt;</code></p><p>An XSLT processor may output the result tree as a sequence of bytes,\nalthough it is not required to be able to do so (see <a href = \"#conformance\">[<b>17 Conformance</b>]</a>). The <code>xsl:output</code>\nelement allows stylesheet authors to specify how they wish the result tree to\nbe output. If an XSLT processor outputs the result tree, it should do so as\nspecified by the <code>xsl:output</code> element; however, it is not required\nto do so.</p><p>The <code>xsl:output</code> element is only allowed as a <a href = \"#dt-top-level\">top-level</a> element.</p><p>The <code>method</code> attribute on <code>xsl:output</code> identifies\nthe overall method that should be used for outputting the result tree.  The\nvalue must be a <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a>.  If the <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a> does not have a\nprefix, then it identifies a method specified in this document and must be\none of <code>xml</code>, <code>html</code> or <code>text</code>.  If the <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a> has a prefix,\nthen the <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a> is\nexpanded into an <a href = \"http://www.w3.org/TR/xpath#dt-expanded-name\">expanded-name</a> as\ndescribed in <a href = \"#qname\">[<b>2.4 Qualified Names</b>]</a>; the\nexpanded-name identifies the output method; the behavior in this case is not\nspecified by this document.</p><p>The default for the <code>method</code> attribute is chosen as follows. \nIf</p><ul>\n  <li><p>the root node of the result tree has an element child,</p>\n  </li>\n  <li><p>the expanded-name of the first element child of the root node (i.e.\n    the document element) of the result tree has local part <code>html</code>\n    (in any combination of upper and lower case) and a null namespace URI,\n    and</p>\n  </li>\n  <li><p>any text nodes preceding the first element child of the root node of\n    the result tree contain only whitespace characters,</p>\n  </li>\n</ul><p>then the default output method is <code>html</code>; otherwise, the\ndefault output method is <code>xml</code>.  The default output method should\nbe used if there are no <code>xsl:output</code> elements or if none of the\n<code>xsl:output</code> elements specifies a value for the\n<code>method</code> attribute.</p><p>The other attributes on <code>xsl:output</code> provide parameters for the\noutput method.  The following attributes are allowed:</p><ul>\n  <li><p><code>version</code> specifies the version of the output method</p>\n  </li>\n  <li><p><code>indent</code> specifies whether the XSLT processor may add\n    additional whitespace when outputting the result tree; the value must be\n    <code>yes</code> or <code>no</code></p>\n  </li>\n  <li><p><code>encoding</code> specifies the preferred character encoding\n    that the XSLT processor should use to encode sequences of characters as\n    sequences of bytes; the value of the attribute should be treated\n    case-insensitively; the value must contain only characters in the range\n    #x21 to #x7E (i.e. printable ASCII characters); the value should either\n    be a <code>charset</code> registered with the Internet Assigned Numbers\n    Authority <a href = \"#IANA\">[IANA]</a>, <a href = \"#RFC2278\">[RFC2278]</a> or\n    start with <code>X-</code></p>\n  </li>\n  <li><p><code>media-type</code> specifies the media type (MIME content type)\n    of the data that results from outputting the result tree; the\n    <code>charset</code> parameter should not be specified explicitly;\n    instead, when the top-level media type is <code>text</code>, a\n    <code>charset</code> parameter should be added according to the character\n    encoding actually used by the output method</p>\n  </li>\n  <li><p><code>doctype-system</code> specifies the system identifier to be\n    used in the document type declaration</p>\n  </li>\n  <li><p><code>doctype-public</code> specifies the public identifier to be\n    used in the document type declaration</p>\n  </li>\n  <li><p><code>omit-xml-declaration</code> specifies whether the XSLT\n    processor should output an XML declaration; the value must be\n    <code>yes</code> or <code>no</code></p>\n  </li>\n  <li><p><code>standalone</code> specifies whether the XSLT processor should\n    output a standalone document declaration; the value must be\n    <code>yes</code> or <code>no</code></p>\n  </li>\n  <li><p><code>cdata-section-elements</code> specifies a list of the names of\n    elements whose text node children should be output using CDATA\n    sections</p>\n  </li>\n</ul><p>The detailed semantics of each attribute will be described separately for\neach output method for which it is applicable.  If the semantics of an\nattribute are not described for an output method, then it is not applicable\nto that output method.</p><p>A stylesheet may contain multiple <code>xsl:output</code> elements and may\ninclude or import stylesheets that also contain <code>xsl:output</code>\nelements.  All the <code>xsl:output</code> elements occurring in a stylesheet\nare merged into a single effective <code>xsl:output</code> element. For the\n<code>cdata-section-elements</code> attribute, the effective value is the\nunion of the specified values.  For other attributes, the effective value is\nthe specified value with the highest <a href = \"#dt-import-precedence\">import\nprecedence</a>. It is an error if there is more than one such value for an\nattribute.  An XSLT processor may signal the error; if it does not signal the\nerror, if should recover by using the value that occurs last in the\nstylesheet. The values of attributes are defaulted after the\n<code>xsl:output</code> elements have been merged; different output methods\nmay have different default values for an attribute.</p><h3><a name = \"section-XML-Output-Method\" id = \"section-XML-Output-Method\"></a>16.1 XML Output Method</h3><p>The <code>xml</code> output method outputs the result tree as a\nwell-formed XML external general parsed entity. If the root node of the\nresult tree has a single element node child and no text node children, then\nthe entity should also be a well-formed XML document entity. When the entity\nis referenced within a trivial XML document wrapper like this</p><pre>&lt;!DOCTYPE doc [\n&lt;!ENTITY e SYSTEM \"<var>entity-URI</var>\"&gt;\n]&gt;\n&lt;doc&gt;&amp;e;&lt;/doc&gt;</pre><p>where <code><var>entity-URI</var></code> is a URI for the entity, then the\nwrapper document as a whole should be a well-formed XML document conforming\nto the XML Namespaces Recommendation <a href = \"#XMLNAMES\">[XML Names]</a>.  In\naddition, the output should be such that if a new tree was constructed by\nparsing the wrapper as an XML document as specified in <a href = \"#data-model\">[<b>3 Data Model</b>]</a>, and then removing the document\nelement, making its children instead be children of the root node, then the\nnew tree would be the same as the result tree, with the following possible\nexceptions:</p><ul>\n  <li><p>The order of attributes in the two trees may be different.</p>\n  </li>\n  <li><p>The new tree may contain namespace nodes that were not present in\n    the result tree.</p>\n\n    <blockquote>\n      <b>NOTE:</b>An XSLT processor may need to add namespace declarations in\n      the course of outputting the result tree as XML.</blockquote>\n  </li>\n</ul><p>If the XSLT processor generated a document type declaration because of the\n<code>doctype-system</code> attribute, then the above requirements apply to\nthe entity with the generated document type declaration removed.</p><p>The <code>version</code> attribute specifies the version of XML to be used\nfor outputting the result tree.  If the XSLT processor does not support this\nversion of XML, it should use a version of XML that it does support.  The\nversion output in the XML declaration (if an XML declaration is output)\nshould correspond to the version of XML that the processor used for\noutputting the result tree. The value of the <code>version</code> attribute\nshould match the <a href = \"http://www.w3.org/TR/REC-xml#NT-VersionNum\">VersionNum</a> production\nof the XML Recommendation <a href = \"#XML\">[XML]</a>. The default value is\n<code>1.0</code>.</p><p>The <code>encoding</code> attribute specifies the preferred encoding to\nuse for outputting the result tree.  XSLT processors are required to respect\nvalues of <code>UTF-8</code> and <code>UTF-16</code>.  For other values, if\nthe XSLT processor does not support the specified encoding it may signal an\nerror; if it does not signal an error it should use <code>UTF-8</code> or\n<code>UTF-16</code> instead.  The XSLT processor must not use an encoding\nwhose name does not match the <a href = \"http://www.w3.org/TR/REC-xml#NT-EncName\">EncName</a> production of the\nXML Recommendation <a href = \"#XML\">[XML]</a>.  If no <code>encoding</code>\nattribute is specified, then the XSLT processor should use either\n<code>UTF-8</code> or <code>UTF-16</code>.  It is possible that the result\ntree will contain a character that cannot be represented in the encoding that\nthe XSLT processor is using for output.  In this case, if the character\noccurs in a context where XML recognizes character references (i.e. in the\nvalue of an attribute node or text node), then the character should be output\nas a character reference; otherwise (for example if the character occurs in\nthe name of an element) the XSLT processor should signal an error.</p><p>If the <code>indent</code> attribute has the value <code>yes</code>, then\nthe <code>xml</code> output method may output whitespace in addition to the\nwhitespace in the result tree (possibly based on whitespace stripped from\neither the source document or the stylesheet) in order to indent the result\nnicely; if the <code>indent</code> attribute has the value <code>no</code>,\nit should not output any additional whitespace. The default value is\n<code>no</code>.  The <code>xml</code> output method should use an algorithm\nto output additional whitespace that ensures that the result if whitespace\nwere to be stripped from the output using the process described in <a href = \"#strip\">[<b>3.4 Whitespace Stripping</b>]</a> with the set of\nwhitespace-preserving elements consisting of just <code>xsl:text</code> would\nbe the same when additional whitespace is output as when additional\nwhitespace is not output.</p><blockquote>\n  <b>NOTE:</b>It is usually not safe to use <code>indent=\"yes\"</code> with\n  document types that include element types with mixed content.</blockquote><p>The <code>cdata-section-elements</code> attribute contains a\nwhitespace-separated list of <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a>s.  Each <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a> is expanded into\nan expanded-name using the namespace declarations in effect on the\n<code>xsl:output</code> element in which the <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a> occurs; if there\nis a default namespace, it is used for <a href = \"http://www.w3.org/TR/REC-xml-names#NT-QName\">QName</a>s that do not\nhave a prefix.  The expansion is performed before the merging of multiple\n<code>xsl:output</code> elements into a single effective\n<code>xsl:output</code> element. If the expanded-name of the parent of a text\nnode is a member of the list, then the text node should be output as a CDATA\nsection. For example,</p><pre>&lt;xsl:output cdata-section-elements=\"example\"/&gt;</pre><p>would cause a literal result element written in the stylesheet as</p><pre>&lt;example&gt;&amp;lt;foo&gt;&lt;/example&gt;</pre><p>or as</p><pre>&lt;example&gt;&lt;![CDATA[&lt;foo&gt;]]&gt;&lt;/example&gt;</pre><p>to be output as</p><pre>&lt;example&gt;&lt;![CDATA[&lt;foo&gt;]]&gt;&lt;/example&gt;</pre><p>If the text node contains the sequence of characters <code>]]&gt;</code>,\nthen the currently open CDATA section should be closed following the\n<code>]]</code> and a new CDATA section opened before the <code>&gt;</code>.\nFor example, a literal result element written in the stylesheet as</p><pre>&lt;example&gt;]]&amp;gt;&lt;/example&gt;</pre><p>would be output as</p><pre>&lt;example&gt;&lt;![CDATA[]]]]&gt;&lt;![CDATA[&gt;]]&gt;&lt;/example&gt;</pre><p>If the text node contains a character that is not representable in the\ncharacter encoding being used to output the result tree, then the currently\nopen CDATA section should be closed before the character, the character\nshould be output using a character reference or entity reference, and a new\nCDATA section should be opened for any further characters in the text\nnode.</p><p>CDATA sections should not be used except for text nodes that the\n<code>cdata-section-elements</code> attribute explicitly specifies should be\noutput using CDATA sections.</p><p>The <code>xml</code> output method should output an XML declaration unless\nthe <code>omit-xml-declaration</code> attribute has the value\n<code>yes</code>. The XML declaration should include both version information\nand an encoding declaration. If the <code>standalone</code> attribute is\nspecified, it should include a standalone document declaration with the same\nvalue as the value as the value of the <code>standalone</code> attribute. \nOtherwise, it should not include a standalone document declaration; this\nensures that it is both a XML declaration (allowed at the beginning of a\ndocument entity) and a text declaration (allowed at the beginning of an\nexternal general parsed entity).</p><p>If the <code>doctype-system</code> attribute is specified, the\n<code>xml</code> output method should output a document type declaration\nimmediately before the first element.  The name following\n<code>&lt;!DOCTYPE</code> should be the name of the first element.  If\n<code>doctype-public</code> attribute is also specified, then the\n<code>xml</code> output method should output <code>PUBLIC</code> followed by\nthe public identifier and then the system identifier; otherwise, it should\noutput <code>SYSTEM</code> followed by the system identifier.  The internal\nsubset should be empty.  The <code>doctype-public</code> attribute should be\nignored unless the <code>doctype-system</code> attribute is specified.</p><p>The <code>media-type</code> attribute is applicable for the\n<code>xml</code> output method.  The default value for the\n<code>media-type</code> attribute is <code>text/xml</code>.</p><h3><a name = \"section-HTML-Output-Method\" id = \"section-HTML-Output-Method\"></a>16.2 HTML Output Method</h3><p>The <code>html</code> output method outputs the result tree as HTML; for\nexample,</p><pre>&lt;xsl:stylesheet version=\"1.0\"\n                xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"&gt;\n\n&lt;xsl:output method=\"html\"/&gt;\n\n&lt;xsl:template match=\"/\"&gt;\n  &lt;html&gt;\n   &lt;xsl:apply-templates/&gt;\n  &lt;/html&gt;\n&lt;/xsl:template&gt;\n\n...\n\n&lt;/xsl:stylesheet&gt;</pre><p>The <code>version</code> attribute indicates the version of the HTML.  The\ndefault value is <code>4.0</code>, which specifies that the result should be\noutput as HTML conforming to the HTML 4.0 Recommendation <a href = \"#HTML\">[HTML]</a>.</p><p>The <code>html</code> output method should not output an element\ndifferently from the <code>xml</code> output method unless the expanded-name\nof the element has a null namespace URI; an element whose expanded-name has a\nnon-null namespace URI should be output as XML.  If the expanded-name of the\nelement has a null namespace URI, but the local part of the expanded-name is\nnot recognized as the name of an HTML element, the element should output in\nthe same way as a non-empty, inline element such as <code>span</code>.</p><p>The <code>html</code> output method should not output an end-tag for empty\nelements.  For HTML 4.0, the empty elements are <code>area</code>,\n<code>base</code>, <code>basefont</code>, <code>br</code>, <code>col</code>,\n<code>frame</code>, <code>hr</code>, <code>img</code>, <code>input</code>,\n<code>isindex</code>, <code>link</code>, <code>meta</code> and\n<code>param</code>. For example, an element written as\n<code>&lt;br/&gt;</code> or <code>&lt;br&gt;&lt;/br&gt;</code> in the\nstylesheet should be output as <code>&lt;br&gt;</code>.</p><p>The <code>html</code> output method should recognize the names of HTML\nelements regardless of case.  For example, elements named <code>br</code>,\n<code>BR</code> or <code>Br</code> should all be recognized as the HTML\n<code>br</code> element and output without an end-tag.</p><p>The <code>html</code> output method should not perform escaping for the\ncontent of the <code>script</code> and <code>style</code> elements. For\nexample, a literal result element written in the stylesheet as</p><pre>&lt;script&gt;if (a &amp;lt; b) foo()&lt;/script&gt;</pre><p>or</p><pre>&lt;script&gt;&lt;![CDATA[if (a &lt; b) foo()]]&gt;&lt;/script&gt;</pre><p>should be output as</p><pre>&lt;script&gt;if (a &lt; b) foo()&lt;/script&gt;</pre><p>The <code>html</code> output method should not escape <code>&lt;</code>\ncharacters occurring in attribute values.</p><p>If the <code>indent</code> attribute has the value <code>yes</code>, then\nthe <code>html</code> output method may add or remove whitespace as it\noutputs the result tree, so long as it does not change how an HTML user agent\nwould render the output.  The default value is <code>yes</code>.</p><p>The <code>html</code> output method should escape non-ASCII characters in\nURI attribute values using the method recommended in <a href = \"http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.2.1\">Section\nB.2.1</a> of the HTML 4.0 Recommendation.</p><p>The <code>html</code> output method may output a character using a\ncharacter entity reference, if one is defined for it in the version of HTML\nthat the output method is using.</p><p>The <code>html</code> output method should terminate processing\ninstructions with <code>&gt;</code> rather than <code>?&gt;</code>.</p><p>The <code>html</code> output method should output boolean attributes (that\nis attributes with only a single allowed value that is equal to the name of\nthe attribute) in minimized form. For example, a start-tag written in the\nstylesheet as</p><pre>&lt;OPTION selected=\"selected\"&gt;</pre><p>should be output as</p><pre>&lt;OPTION selected&gt;</pre><p>The <code>html</code> output method should not escape a <code>&amp;</code>\ncharacter occurring in an attribute value immediately followed by a\n<code>{</code> character (see <a href = \"http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.7.1.1\">Section\nB.7.1</a> of the HTML 4.0 Recommendation). For example, a start-tag written\nin the stylesheet as</p><pre>&lt;BODY bgcolor='&amp;amp;{{randomrbg}};'&gt;</pre><p>should be output as</p><pre>&lt;BODY bgcolor='&amp;{randomrbg};'&gt;</pre><p>The <code>encoding</code> attribute specifies the preferred encoding to be\nused. If there is a <code>HEAD</code> element, then the <code>html</code>\noutput method should add a <code>META</code> element immediately after the\nstart-tag of the <code>HEAD</code> element specifying the character encoding\nactually used. For example,</p><pre>&lt;HEAD&gt;\n&lt;META http-equiv=\"Content-Type\" content=\"text/html; charset=EUC-JP\"&gt;\n...</pre><p>It is possible that the result tree will contain a character that cannot\nbe represented in the encoding that the XSLT processor is using for output. \nIn this case, if the character occurs in a context where HTML recognizes\ncharacter references, then the character should be output as a character\nentity reference or decimal numeric character reference; otherwise (for\nexample, in a <code>script</code> or <code>style</code> element or in a\ncomment), the XSLT processor should signal an error.</p><p>If the <code>doctype-public</code> or <code>doctype-system</code>\nattributes are specified, then the <code>html</code> output method should\noutput a document type declaration immediately before the first element.  The\nname following <code>&lt;!DOCTYPE</code> should be <code>HTML</code> or\n<code>html</code>.  If the <code>doctype-public</code> attribute is\nspecified, then the output method should output <code>PUBLIC</code> followed\nby the specified public identifier; if the <code>doctype-system</code>\nattribute is also specified, it should also output the specified system\nidentifier following the public identifier.  If the\n<code>doctype-system</code> attribute is specified but the\n<code>doctype-public</code> attribute is not specified, then the output\nmethod should output <code>SYSTEM</code> followed by the specified system\nidentifier.</p><p>The <code>media-type</code> attribute is applicable for the\n<code>html</code> output method.  The default value is\n<code>text/html</code>.</p><h3><a name = \"section-Text-Output-Method\" id = \"section-Text-Output-Method\"></a>16.3 Text Output Method</h3><p>The <code>text</code> output method outputs the result tree by outputting\nthe string-value of every text node in the result tree in document order\nwithout any escaping.</p><p>The <code>media-type</code> attribute is applicable for the\n<code>text</code> output method.  The default value for the\n<code>media-type</code> attribute is <code>text/plain</code>.</p><p>The <code>encoding</code> attribute identifies the encoding that the\n<code>text</code> output method should use to convert sequences of characters\nto sequences of bytes.  The default is system-dependent. If the result tree\ncontains a character that cannot be represented in the encoding that the XSLT\nprocessor is using for output, the XSLT processor should signal an error.</p><h3><a name = \"disable-output-escaping\" id = \"disable-output-escaping\"></a>16.4 Disabling Output Escaping</h3><p>Normally, the <code>xml</code> output method escapes &amp; and &lt; (and\npossibly other characters) when outputting text nodes.  This ensures that the\noutput is well-formed XML. However, it is sometimes convenient to be able to\nproduce output that is almost, but not quite well-formed XML; for example,\nthe output may include ill-formed sections which are intended to be\ntransformed into well-formed XML by a subsequent non-XML aware process.  For\nthis reason, XSLT provides a mechanism for disabling output escaping. An\n<code>xsl:value-of</code> or <code>xsl:text</code> element may have a\n<code>disable-output-escaping</code> attribute; the allowed values are\n<code>yes</code> or <code>no</code>; the default is <code>no</code>; if the\nvalue is <code>yes</code>, then a text node generated by instantiating the\n<code>xsl:value-of</code> or <code>xsl:text</code> element should be output\nwithout any escaping. For example,</p><pre>&lt;xsl:text disable-output-escaping=\"yes\"&gt;&amp;lt;&lt;/xsl:text&gt;</pre><p>should generate the single character <code>&lt;</code>.</p><p>It is an error for output escaping to be disabled for a text node that is\nused for something other than a text node in the result tree. Thus, it is an\nerror to disable output escaping for an <code>xsl:value-of</code> or\n<code>xsl:text</code> element that is used to generate the string-value of a\ncomment, processing instruction or attribute node; it is also an error to\nconvert a <a href = \"#dt-result-tree-fragment\">result tree fragment</a> to a\nnumber or a string if the result tree fragment contains a text node for which\nescaping was disabled.  In both cases, an XSLT processor may signal the\nerror; if it does not signal the error, it must recover by ignoring the\n<code>disable-output-escaping</code> attribute.</p><p>The <code>disable-output-escaping</code> attribute may be used with the\n<code>html</code> output method as well as with the <code>xml</code> output\nmethod.  The <code>text</code> output method ignores the\n<code>disable-output-escaping</code> attribute, since it does not perform any\noutput escaping.</p><p>An XSLT processor will only be able to disable output escaping if it\ncontrols how the result tree is output. This may not always be the case.  For\nexample, the result tree may be used as the source tree for another XSLT\ntransformation instead of being output.  An XSLT processor is not required to\nsupport disabling output escaping.  If an <code>xsl:value-of</code> or\n<code>xsl:text</code> specifies that output escaping should be disabled and\nthe XSLT processor does not support this, the XSLT processor may signal an\nerror; if it does not signal an error, it must recover by not disabling\noutput escaping.</p><p>If output escaping is disabled for a character that is not representable\nin the encoding that the XSLT processor is using for output, then the XSLT\nprocessor may signal an error; if it does not signal an error, it must\nrecover by not disabling output escaping.</p><p>Since disabling output escaping may not work with all XSLT processors and\ncan result in XML that is not well-formed, it should be used only when there\nis no alternative.</p><h2><a name = \"conformance\" id = \"conformance\"></a>17 Conformance</h2><p>A conforming XSLT processor must be able to use a stylesheet to transform\na source tree into a result tree as specified in this document.  A conforming\nXSLT processor need not be able to output the result in XML or in any other\nform.</p><blockquote>\n  <b>NOTE:</b>Vendors of XSLT processors are strongly encouraged to provide a\n  way to verify that their processor is behaving conformingly by allowing the\n  result tree to be output as XML or by providing access to the result tree\n  through a standard API such as the DOM or SAX.</blockquote><p>A conforming XSLT processor must signal any errors except for those that\nthis document specifically allows an XSLT processor not to signal. A\nconforming XSLT processor may but need not recover from any errors that it\nsignals.</p><p>A conforming XSLT processor may impose limits on the processing resources\nconsumed by the processing of a stylesheet.</p><h2><a name = \"notation\" id = \"notation\"></a>18 Notation</h2><p>The specification of each XSLT-defined element type is preceded by a\nsummary of its syntax in the form of a model for elements of that element\ntype.  The meaning of syntax summary notation is as follows:</p><ul>\n  <li><p>An attribute is required if and only if its name is in bold.</p>\n  </li>\n  <li><p>The string that occurs in the place of an attribute value specifies\n    the allowed values of the attribute.  If this is surrounded by curly\n    braces, then the attribute value is treated as an <a href = \"#dt-attribute-value-template\">attribute value template</a>, and the\n    string occurring within curly braces specifies the allowed values of the\n    result of instantiating the attribute value template. Alternative allowed\n    values are separated by <code>|</code>.  A quoted string indicates a\n    value equal to that specific string. An unquoted, italicized name\n    specifies a particular type of value.</p>\n  </li>\n  <li><p>If the element is allowed not to be empty, then the element contains\n    a comment specifying the allowed content.  The allowed content is\n    specified in a similar way to an element type declaration in XML;\n    <i>template</i> means that any mixture of text nodes, literal result\n    elements, extension elements, and XSLT elements from the\n    <code>instruction</code> category is allowed; <i>top-level-elements</i>\n    means that any mixture of XSLT elements from the\n    <code>top-level-element</code> category is allowed.</p>\n  </li>\n  <li><p>The element is prefaced by comments indicating if it belongs to the\n    <code>instruction</code> category or <code>top-level-element</code>\n    category or both.  The category of an element just affects whether it is\n    allowed in the content of elements that allow a <i>template</i> or\n    <i>top-level-elements</i>.</p>\n  </li>\n</ul><hr title = \"Separator from footer\"/><h2><a name = \"section-References\" id = \"section-References\"></a>A References</h2><h3><a name = \"section-Normative-References\" id = \"section-Normative-References\"></a>A.1 Normative References</h3><dl>\n  <dt><a name = \"XML\" id = \"XML\">XML</a></dt>\n    <dd>World Wide Web Consortium. <i>Extensible Markup Language (XML)\n      1.0.</i> W3C Recommendation. See <a href = \"http://www.w3.org/TR/1998/REC-xml-19980210\">http://www.w3.org/TR/1998/REC-xml-19980210</a></dd>\n  <dt><a name = \"XMLNAMES\" id = \"XMLNAMES\">XML Names</a></dt>\n    <dd>World Wide Web Consortium. <i>Namespaces in XML.</i> W3C\n      Recommendation. See <a href = \"http://www.w3.org/TR/REC-xml-names\">http://www.w3.org/TR/REC-xml-names</a></dd>\n  <dt><a name = \"XPATH\" id = \"XPATH\">XPath</a></dt>\n    <dd>World Wide Web Consortium. <i>XML Path Language.</i> W3C\n      Recommendation. See <a href = \"http://www.w3.org/TR/xpath\">http://www.w3.org/TR/xpath</a></dd>\n</dl><h3><a name = \"section-Other-References\" id = \"section-Other-References\"></a>A.2 Other References</h3><dl>\n  <dt><a name = \"CSS2\" id = \"CSS2\">CSS2</a></dt>\n    <dd>World Wide Web Consortium.  <i>Cascading Style Sheets, level 2\n      (CSS2)</i>.  W3C Recommendation.  See <a href = \"http://www.w3.org/TR/1998/REC-CSS2-19980512\">http://www.w3.org/TR/1998/REC-CSS2-19980512</a></dd>\n  <dt><a name = \"DSSSL\" id = \"DSSSL\">DSSSL</a></dt>\n    <dd>International Organization for Standardization, International\n      Electrotechnical Commission. <i>ISO/IEC 10179:1996.  Document Style\n      Semantics and Specification Language (DSSSL)</i>.  International\n      Standard.</dd>\n  <dt><a name = \"HTML\" id = \"HTML\">HTML</a></dt>\n    <dd>World Wide Web Consortium. <i>HTML 4.0 specification</i>. W3C\n      Recommendation. See <a href = \"http://www.w3.org/TR/REC-html40\">http://www.w3.org/TR/REC-html40</a></dd>\n  <dt><a name = \"IANA\" id = \"IANA\">IANA</a></dt>\n    <dd>Internet Assigned Numbers Authority. <i>Character Sets</i>. See <a href = \"ftp://ftp.isi.edu/in-notes/iana/assignments/character-sets\">ftp://ftp.isi.edu/in-notes/iana/assignments/character-sets</a>.</dd>\n  <dt><a name = \"RFC2278\" id = \"RFC2278\">RFC2278</a></dt>\n    <dd>N. Freed, J. Postel.  <i>IANA Charset Registration Procedures</i>. \n      IETF RFC 2278. See <a href = \"http://www.ietf.org/rfc/rfc2278.txt\">http://www.ietf.org/rfc/rfc2278.txt</a>.</dd>\n  <dt><a name = \"RFC2376\" id = \"RFC2376\">RFC2376</a></dt>\n    <dd>E. Whitehead, M. Murata.  <i>XML Media Types</i>. IETF RFC 2376. See\n      <a href = \"http://www.ietf.org/rfc/rfc2376.txt\">http://www.ietf.org/rfc/rfc2376.txt</a>.</dd>\n  <dt><a name = \"RFC2396\" id = \"RFC2396\">RFC2396</a></dt>\n    <dd>T. Berners-Lee, R. Fielding, and L. Masinter.  <i>Uniform Resource\n      Identifiers (URI): Generic Syntax</i>. IETF RFC 2396. See <a href = \"http://www.ietf.org/rfc/rfc2396.txt\">http://www.ietf.org/rfc/rfc2396.txt</a>.</dd>\n  <dt><a name = \"UNICODE-TR10\" id = \"UNICODE-TR10\">UNICODE TR10</a></dt>\n    <dd>Unicode Consortium. <i>Unicode Technical Report #10. Unicode\n      Collation Algorithm</i>.  Unicode Technical Report.  See <a href = \"http://www.unicode.org/unicode/reports/tr10/index.html\">http://www.unicode.org/unicode/reports/tr10/index.html</a>.</dd>\n  <dt><a name = \"XHTML\" id = \"XHTML\">XHTML</a></dt>\n    <dd>World Wide Web Consortium. <i>XHTML 1.0: The Extensible HyperText\n      Markup Language.</i> W3C Proposed Recommendation. See <a href = \"http://www.w3.org/TR/xhtml1\">http://www.w3.org/TR/xhtml1</a></dd>\n  <dt><a name = \"XPTR\" id = \"XPTR\">XPointer</a></dt>\n    <dd>World Wide Web Consortium. <i>XML Pointer Language (XPointer).</i>\n      W3C Working Draft. See <a href = \"http://www.w3.org/TR/xptr\">http://www.w3.org/TR/xptr</a></dd>\n  <dt><a name = \"XMLSTYLE\" id = \"XMLSTYLE\">XML Stylesheet</a></dt>\n    <dd>World Wide Web Consortium. <i>Associating stylesheets with XML\n      documents.</i> W3C Recommendation. See <a href = \"http://www.w3.org/TR/xml-stylesheet\">http://www.w3.org/TR/xml-stylesheet</a></dd>\n  <dt><a name = \"XSL\" id = \"XSL\">XSL</a></dt>\n    <dd>World Wide Web Consortium.  <i>Extensible Stylesheet Language\n      (XSL).</i>  W3C Working Draft.  See <a href = \"http://www.w3.org/TR/WD-xsl\">http://www.w3.org/TR/WD-xsl</a></dd>\n</dl><h2><a name = \"element-syntax-summary\" id = \"element-syntax-summary\"></a>B Element Syntax Summary</h2><p class = \"element-syntax-summary\"><code>&lt;!-- Category: instruction\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-apply-imports\">xsl:apply-imports</a>&nbsp;/&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: instruction\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-apply-templates\">xsl:apply-templates</a> <br/>\n&nbsp;&nbsp;select = <var>node-set-expression</var> <br/>\n&nbsp;&nbsp;mode = <var>qname</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: (<a href = \"#XSLT_element-sort\">xsl:sort</a> | <a href = \"#XSLT_element-with-param\">xsl:with-param</a>)* --&gt;<br/>\n&lt;/xsl:apply-templates&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: instruction\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-attribute\">xsl:attribute</a> <br/>\n&nbsp;&nbsp;<b>name</b> = { <var>qname</var> }<br/>\n&nbsp;&nbsp;namespace = { <var>uri-reference</var> }&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:attribute&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: top-level-element\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-attribute-set\">xsl:attribute-set</a> <br/>\n&nbsp;&nbsp;<b>name</b> = <var>qname</var> <br/>\n&nbsp;&nbsp;use-attribute-sets = <var>qnames</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <a href = \"#XSLT_element-attribute\">xsl:attribute</a>*\n--&gt;<br/>\n&lt;/xsl:attribute-set&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: instruction\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-call-template\">xsl:call-template</a> <br/>\n&nbsp;&nbsp;<b>name</b> = <var>qname</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <a href = \"#XSLT_element-with-param\">xsl:with-param</a>* --&gt;<br/>\n&lt;/xsl:call-template&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: instruction\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-choose\">xsl:choose</a>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: (<a href = \"#XSLT_element-when\">xsl:when</a>+, <a href = \"#XSLT_element-otherwise\">xsl:otherwise</a>?) --&gt;<br/>\n&lt;/xsl:choose&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: instruction\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-comment\">xsl:comment</a>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:comment&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: instruction\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-copy\">xsl:copy</a> <br/>\n&nbsp;&nbsp;use-attribute-sets = <var>qnames</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:copy&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: instruction\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-copy-of\">xsl:copy-of</a> <br/>\n&nbsp;&nbsp;<b>select</b> = <var>expression</var>&nbsp;/&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: top-level-element\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-decimal-format\">xsl:decimal-format</a> <br/>\n&nbsp;&nbsp;name = <var>qname</var> <br/>\n&nbsp;&nbsp;decimal-separator = <var>char</var> <br/>\n&nbsp;&nbsp;grouping-separator = <var>char</var> <br/>\n&nbsp;&nbsp;infinity = <var>string</var> <br/>\n&nbsp;&nbsp;minus-sign = <var>char</var> <br/>\n&nbsp;&nbsp;NaN = <var>string</var> <br/>\n&nbsp;&nbsp;percent = <var>char</var> <br/>\n&nbsp;&nbsp;per-mille = <var>char</var> <br/>\n&nbsp;&nbsp;zero-digit = <var>char</var> <br/>\n&nbsp;&nbsp;digit = <var>char</var> <br/>\n&nbsp;&nbsp;pattern-separator = <var>char</var>&nbsp;/&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: instruction\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-element\">xsl:element</a> <br/>\n&nbsp;&nbsp;<b>name</b> = { <var>qname</var> }<br/>\n&nbsp;&nbsp;namespace = { <var>uri-reference</var> }<br/>\n&nbsp;&nbsp;use-attribute-sets = <var>qnames</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:element&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: instruction\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-fallback\">xsl:fallback</a>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:fallback&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: instruction\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-for-each\">xsl:for-each</a> <br/>\n&nbsp;&nbsp;<b>select</b> = <var>node-set-expression</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: (<a href = \"#XSLT_element-sort\">xsl:sort</a>*,\n<var>template</var>) --&gt;<br/>\n&lt;/xsl:for-each&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: instruction\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-if\">xsl:if</a> <br/>\n&nbsp;&nbsp;<b>test</b> = <var>boolean-expression</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:if&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;<a href = \"#XSLT_element-import\">xsl:import</a> <br/>\n&nbsp;&nbsp;<b>href</b> = <var>uri-reference</var>&nbsp;/&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: top-level-element\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-include\">xsl:include</a> <br/>\n&nbsp;&nbsp;<b>href</b> = <var>uri-reference</var>&nbsp;/&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: top-level-element\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-key\">xsl:key</a> <br/>\n&nbsp;&nbsp;<b>name</b> = <var>qname</var> <br/>\n&nbsp;&nbsp;<b>match</b> = <var>pattern</var> <br/>\n&nbsp;&nbsp;<b>use</b> = <var>expression</var>&nbsp;/&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: instruction\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-message\">xsl:message</a> <br/>\n&nbsp;&nbsp;terminate = \"yes\" | \"no\"&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:message&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: top-level-element\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-namespace-alias\">xsl:namespace-alias</a> <br/>\n&nbsp;&nbsp;<b>stylesheet-prefix</b> = <var>prefix</var> | \"#default\"<br/>\n&nbsp;&nbsp;<b>result-prefix</b> = <var>prefix</var> |\n\"#default\"&nbsp;/&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: instruction\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-number\">xsl:number</a> <br/>\n&nbsp;&nbsp;level = \"single\" | \"multiple\" | \"any\"<br/>\n&nbsp;&nbsp;count = <var>pattern</var> <br/>\n&nbsp;&nbsp;from = <var>pattern</var> <br/>\n&nbsp;&nbsp;value = <var>number-expression</var> <br/>\n&nbsp;&nbsp;format = { <var>string</var> }<br/>\n&nbsp;&nbsp;lang = { <var>nmtoken</var> }<br/>\n&nbsp;&nbsp;letter-value = { \"alphabetic\" | \"traditional\" }<br/>\n&nbsp;&nbsp;grouping-separator = { <var>char</var> }<br/>\n&nbsp;&nbsp;grouping-size = { <var>number</var> }&nbsp;/&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;<a href = \"#XSLT_element-otherwise\">xsl:otherwise</a>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:otherwise&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: top-level-element\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-output\">xsl:output</a> <br/>\n&nbsp;&nbsp;method = \"xml\" | \"html\" | \"text\" |\n<var>qname-but-not-ncname</var> <br/>\n&nbsp;&nbsp;version = <var>nmtoken</var> <br/>\n&nbsp;&nbsp;encoding = <var>string</var> <br/>\n&nbsp;&nbsp;omit-xml-declaration = \"yes\" | \"no\"<br/>\n&nbsp;&nbsp;standalone = \"yes\" | \"no\"<br/>\n&nbsp;&nbsp;doctype-public = <var>string</var> <br/>\n&nbsp;&nbsp;doctype-system = <var>string</var> <br/>\n&nbsp;&nbsp;cdata-section-elements = <var>qnames</var> <br/>\n&nbsp;&nbsp;indent = \"yes\" | \"no\"<br/>\n&nbsp;&nbsp;media-type = <var>string</var>&nbsp;/&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: top-level-element\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-param\">xsl:param</a> <br/>\n&nbsp;&nbsp;<b>name</b> = <var>qname</var> <br/>\n&nbsp;&nbsp;select = <var>expression</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:param&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: top-level-element\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-preserve-space\">xsl:preserve-space</a> <br/>\n&nbsp;&nbsp;<b>elements</b> = <var>tokens</var>&nbsp;/&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: instruction\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-processing-instruction\">xsl:processing-instruction</a>\n<br/>\n&nbsp;&nbsp;<b>name</b> = { <var>ncname</var> }&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:processing-instruction&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;<a href = \"#XSLT_element-sort\">xsl:sort</a> <br/>\n&nbsp;&nbsp;select = <var>string-expression</var> <br/>\n&nbsp;&nbsp;lang = { <var>nmtoken</var> }<br/>\n&nbsp;&nbsp;data-type = { \"text\" | \"number\" | <var>qname-but-not-ncname</var>\n}<br/>\n&nbsp;&nbsp;order = { \"ascending\" | \"descending\" }<br/>\n&nbsp;&nbsp;case-order = { \"upper-first\" | \"lower-first\"\n}&nbsp;/&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: top-level-element\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-strip-space\">xsl:strip-space</a> <br/>\n&nbsp;&nbsp;<b>elements</b> = <var>tokens</var>&nbsp;/&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;<a href = \"#XSLT_element-stylesheet\">xsl:stylesheet</a> <br/>\n&nbsp;&nbsp;id = <var>id</var> <br/>\n&nbsp;&nbsp;extension-element-prefixes = <var>tokens</var> <br/>\n&nbsp;&nbsp;exclude-result-prefixes = <var>tokens</var> <br/>\n&nbsp;&nbsp;<b>version</b> = <var>number</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: (<a href = \"#XSLT_element-import\">xsl:import</a>*,\n<var>top-level-elements</var>) --&gt;<br/>\n&lt;/xsl:stylesheet&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: top-level-element\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-template\">xsl:template</a> <br/>\n&nbsp;&nbsp;match = <var>pattern</var> <br/>\n&nbsp;&nbsp;name = <var>qname</var> <br/>\n&nbsp;&nbsp;priority = <var>number</var> <br/>\n&nbsp;&nbsp;mode = <var>qname</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: (<a href = \"#XSLT_element-param\">xsl:param</a>*,\n<var>template</var>) --&gt;<br/>\n&lt;/xsl:template&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: instruction\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-text\">xsl:text</a> <br/>\n&nbsp;&nbsp;disable-output-escaping = \"yes\" | \"no\"&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: #PCDATA --&gt;<br/>\n&lt;/xsl:text&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;<a href = \"#XSLT_element-transform\">xsl:transform</a> <br/>\n&nbsp;&nbsp;id = <var>id</var> <br/>\n&nbsp;&nbsp;extension-element-prefixes = <var>tokens</var> <br/>\n&nbsp;&nbsp;exclude-result-prefixes = <var>tokens</var> <br/>\n&nbsp;&nbsp;<b>version</b> = <var>number</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: (<a href = \"#XSLT_element-import\">xsl:import</a>*,\n<var>top-level-elements</var>) --&gt;<br/>\n&lt;/xsl:transform&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: instruction\n--&gt;<br/>\n&lt;<a href = \"#XSLT_element-value-of\">xsl:value-of</a> <br/>\n&nbsp;&nbsp;<b>select</b> = <var>string-expression</var> <br/>\n&nbsp;&nbsp;disable-output-escaping = \"yes\" | \"no\"&nbsp;/&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;!-- Category: top-level-element\n--&gt;<br/>\n&lt;!-- Category: instruction --&gt;<br/>\n&lt;<a href = \"#XSLT_element-variable\">xsl:variable</a> <br/>\n&nbsp;&nbsp;<b>name</b> = <var>qname</var> <br/>\n&nbsp;&nbsp;select = <var>expression</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:variable&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;<a href = \"#XSLT_element-when\">xsl:when</a> <br/>\n&nbsp;&nbsp;<b>test</b> = <var>boolean-expression</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:when&gt;</code></p><p class = \"element-syntax-summary\"><code>&lt;<a href = \"#XSLT_element-with-param\">xsl:with-param</a> <br/>\n&nbsp;&nbsp;<b>name</b> = <var>qname</var> <br/>\n&nbsp;&nbsp;select = <var>expression</var>&gt;<br/>\n&nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>\n&lt;/xsl:with-param&gt;</code></p><h2><a name = \"dtd\" id = \"dtd\"></a>C DTD Fragment for XSLT Stylesheets (Non-Normative)</h2><blockquote>\n  <b>NOTE:</b>This DTD Fragment is not normative because XML 1.0 DTDs do not\n  support XML Namespaces and thus cannot correctly describe the allowed\n  structure of an XSLT stylesheet.</blockquote><p>The following entity can be used to construct a DTD for XSLT stylesheets\nthat create instances of a particular result DTD.  Before referencing the\nentity, the stylesheet DTD must define a <code>result-elements</code>\nparameter entity listing the allowed result element types.  For example:</p><pre>&lt;!ENTITY % result-elements \"\n  | fo:inline-sequence\n  | fo:block\n\"&gt;</pre><p>Such result elements should be declared to have\n<code>xsl:use-attribute-sets</code> and\n<code>xsl:extension-element-prefixes</code> attributes.  The following entity\ndeclares the <code>result-element-atts</code> parameter for this purpose. The\ncontent that XSLT allows for result elements is the same as it allows for the\nXSLT elements that are declared in the following entity with a content model\nof <code>%template;</code>.  The DTD may use a more restrictive content model\nthan <code>%template;</code> to reflect the constraints of the result DTD.</p><p>The DTD may define the <code>non-xsl-top-level</code> parameter entity to\nallow additional top-level elements from namespaces other than the XSLT\nnamespace.</p><p>The use of the <code>xsl:</code> prefix in this DTD does not imply that\nXSLT stylesheets are required to use this prefix.  Any of the elements\ndeclared in this DTD may have attributes whose name starts with\n<code>xmlns:</code> or is equal to <code>xmlns</code> in addition to the\nattributes declared in this DTD.</p><pre>&lt;!ENTITY % char-instructions \"\n  | xsl:apply-templates\n  | xsl:call-template\n  | xsl:apply-imports\n  | xsl:for-each\n  | xsl:value-of\n  | xsl:copy-of\n  | xsl:number\n  | xsl:choose\n  | xsl:if\n  | xsl:text\n  | xsl:copy\n  | xsl:variable\n  | xsl:message\n  | xsl:fallback\n\"&gt;\n\n&lt;!ENTITY % instructions \"\n  %char-instructions;\n  | xsl:processing-instruction\n  | xsl:comment\n  | xsl:element\n  | xsl:attribute\n\"&gt;\n\n&lt;!ENTITY % char-template \"\n (#PCDATA\n  %char-instructions;)*\n\"&gt;\n\n&lt;!ENTITY % template \"\n (#PCDATA\n  %instructions;\n  %result-elements;)*\n\"&gt;\n\n&lt;!-- Used for the type of an attribute value that is a URI reference.--&gt;\n&lt;!ENTITY % URI \"CDATA\"&gt;\n\n&lt;!-- Used for the type of an attribute value that is a pattern.--&gt;\n&lt;!ENTITY % pattern \"CDATA\"&gt;\n\n&lt;!-- Used for the type of an attribute value that is an\n     attribute value template.--&gt;\n&lt;!ENTITY % avt \"CDATA\"&gt;\n\n&lt;!-- Used for the type of an attribute value that is a QName; the prefix\n     gets expanded by the XSLT processor. --&gt;\n&lt;!ENTITY % qname \"NMTOKEN\"&gt;\n\n&lt;!-- Like qname but a whitespace-separated list of QNames. --&gt;\n&lt;!ENTITY % qnames \"NMTOKENS\"&gt;\n\n&lt;!-- Used for the type of an attribute value that is an expression.--&gt;\n&lt;!ENTITY % expr \"CDATA\"&gt;\n\n&lt;!-- Used for the type of an attribute value that consists\n     of a single character.--&gt;\n&lt;!ENTITY % char \"CDATA\"&gt;\n\n&lt;!-- Used for the type of an attribute value that is a priority. --&gt;\n&lt;!ENTITY % priority \"NMTOKEN\"&gt;\n\n&lt;!ENTITY % space-att \"xml:space (default|preserve) #IMPLIED\"&gt;\n\n&lt;!-- This may be overridden to customize the set of elements allowed\nat the top-level. --&gt;\n\n&lt;!ENTITY % non-xsl-top-level \"\"&gt;\n\n&lt;!ENTITY % top-level \"\n (xsl:import*,\n  (xsl:include\n  | xsl:strip-space\n  | xsl:preserve-space\n  | xsl:output\n  | xsl:key\n  | xsl:decimal-format\n  | xsl:attribute-set\n  | xsl:variable\n  | xsl:param\n  | xsl:template\n  | xsl:namespace-alias\n  %non-xsl-top-level;)*)\n\"&gt;\n\n&lt;!ENTITY % top-level-atts '\n  extension-element-prefixes CDATA #IMPLIED\n  exclude-result-prefixes CDATA #IMPLIED\n  id ID #IMPLIED\n  version NMTOKEN #REQUIRED\n  xmlns:xsl CDATA #FIXED \"http://www.w3.org/1999/XSL/Transform\"\n  %space-att;\n'&gt;\n\n&lt;!-- This entity is defined for use in the ATTLIST declaration\nfor result elements. --&gt;\n\n&lt;!ENTITY % result-element-atts '\n  xsl:extension-element-prefixes CDATA #IMPLIED\n  xsl:exclude-result-prefixes CDATA #IMPLIED\n  xsl:use-attribute-sets %qnames; #IMPLIED\n  xsl:version NMTOKEN #IMPLIED\n'&gt;\n\n&lt;!ELEMENT xsl:stylesheet %top-level;&gt;\n&lt;!ATTLIST xsl:stylesheet %top-level-atts;&gt;\n\n&lt;!ELEMENT xsl:transform %top-level;&gt;\n&lt;!ATTLIST xsl:transform %top-level-atts;&gt;\n\n&lt;!ELEMENT xsl:import EMPTY&gt;\n&lt;!ATTLIST xsl:import href %URI; #REQUIRED&gt;\n\n&lt;!ELEMENT xsl:include EMPTY&gt;\n&lt;!ATTLIST xsl:include href %URI; #REQUIRED&gt;\n\n&lt;!ELEMENT xsl:strip-space EMPTY&gt;\n&lt;!ATTLIST xsl:strip-space elements CDATA #REQUIRED&gt;\n\n&lt;!ELEMENT xsl:preserve-space EMPTY&gt;\n&lt;!ATTLIST xsl:preserve-space elements CDATA #REQUIRED&gt;\n\n&lt;!ELEMENT xsl:output EMPTY&gt;\n&lt;!ATTLIST xsl:output\n  method %qname; #IMPLIED\n  version NMTOKEN #IMPLIED\n  encoding CDATA #IMPLIED\n  omit-xml-declaration (yes|no) #IMPLIED\n  standalone (yes|no) #IMPLIED\n  doctype-public CDATA #IMPLIED\n  doctype-system CDATA #IMPLIED\n  cdata-section-elements %qnames; #IMPLIED\n  indent (yes|no) #IMPLIED\n  media-type CDATA #IMPLIED\n&gt;\n\n&lt;!ELEMENT xsl:key EMPTY&gt;\n&lt;!ATTLIST xsl:key\n  name %qname; #REQUIRED\n  match %pattern; #REQUIRED\n  use %expr; #REQUIRED\n&gt;\n\n&lt;!ELEMENT xsl:decimal-format EMPTY&gt;\n&lt;!ATTLIST xsl:decimal-format\n  name %qname; #IMPLIED\n  decimal-separator %char; \".\"\n  grouping-separator %char; \",\"\n  infinity CDATA \"Infinity\"\n  minus-sign %char; \"-\"\n  NaN CDATA \"NaN\"\n  percent %char; \"%\"\n  per-mille %char; \"&amp;#x2030;\"\n  zero-digit %char; \"0\"\n  digit %char; \"#\"\n  pattern-separator %char; \";\"\n&gt;\n\n&lt;!ELEMENT xsl:namespace-alias EMPTY&gt;\n&lt;!ATTLIST xsl:namespace-alias\n  stylesheet-prefix CDATA #REQUIRED\n  result-prefix CDATA #REQUIRED\n&gt;\n\n&lt;!ELEMENT xsl:template\n (#PCDATA\n  %instructions;\n  %result-elements;\n  | xsl:param)*\n&gt;\n\n&lt;!ATTLIST xsl:template\n  match %pattern; #IMPLIED\n  name %qname; #IMPLIED\n  priority %priority; #IMPLIED\n  mode %qname; #IMPLIED\n  %space-att;\n&gt;\n\n&lt;!ELEMENT xsl:value-of EMPTY&gt;\n&lt;!ATTLIST xsl:value-of\n  select %expr; #REQUIRED\n  disable-output-escaping (yes|no) \"no\"\n&gt;\n\n&lt;!ELEMENT xsl:copy-of EMPTY&gt;\n&lt;!ATTLIST xsl:copy-of select %expr; #REQUIRED&gt;\n\n&lt;!ELEMENT xsl:number EMPTY&gt;\n&lt;!ATTLIST xsl:number\n   level (single|multiple|any) \"single\"\n   count %pattern; #IMPLIED\n   from %pattern; #IMPLIED\n   value %expr; #IMPLIED\n   format %avt; '1'\n   lang %avt; #IMPLIED\n   letter-value %avt; #IMPLIED\n   grouping-separator %avt; #IMPLIED\n   grouping-size %avt; #IMPLIED\n&gt;\n\n&lt;!ELEMENT xsl:apply-templates (xsl:sort|xsl:with-param)*&gt;\n&lt;!ATTLIST xsl:apply-templates\n  select %expr; \"node()\"\n  mode %qname; #IMPLIED\n&gt;\n\n&lt;!ELEMENT xsl:apply-imports EMPTY&gt;\n\n&lt;!-- xsl:sort cannot occur after any other elements or\nany non-whitespace character --&gt;\n\n&lt;!ELEMENT xsl:for-each\n (#PCDATA\n  %instructions;\n  %result-elements;\n  | xsl:sort)*\n&gt;\n\n&lt;!ATTLIST xsl:for-each\n  select %expr; #REQUIRED\n  %space-att;\n&gt;\n\n&lt;!ELEMENT xsl:sort EMPTY&gt;\n&lt;!ATTLIST xsl:sort\n  select %expr; \".\"\n  lang %avt; #IMPLIED\n  data-type %avt; \"text\"\n  order %avt; \"ascending\"\n  case-order %avt; #IMPLIED\n&gt;\n\n&lt;!ELEMENT xsl:if %template;&gt;\n&lt;!ATTLIST xsl:if\n  test %expr; #REQUIRED\n  %space-att;\n&gt;\n\n&lt;!ELEMENT xsl:choose (xsl:when+, xsl:otherwise?)&gt;\n&lt;!ATTLIST xsl:choose %space-att;&gt;\n\n&lt;!ELEMENT xsl:when %template;&gt;\n&lt;!ATTLIST xsl:when\n  test %expr; #REQUIRED\n  %space-att;\n&gt;\n\n&lt;!ELEMENT xsl:otherwise %template;&gt;\n&lt;!ATTLIST xsl:otherwise %space-att;&gt;\n\n&lt;!ELEMENT xsl:attribute-set (xsl:attribute)*&gt;\n&lt;!ATTLIST xsl:attribute-set\n  name %qname; #REQUIRED\n  use-attribute-sets %qnames; #IMPLIED\n&gt;\n\n&lt;!ELEMENT xsl:call-template (xsl:with-param)*&gt;\n&lt;!ATTLIST xsl:call-template\n  name %qname; #REQUIRED\n&gt;\n\n&lt;!ELEMENT xsl:with-param %template;&gt;\n&lt;!ATTLIST xsl:with-param\n  name %qname; #REQUIRED\n  select %expr; #IMPLIED\n&gt;\n\n&lt;!ELEMENT xsl:variable %template;&gt;\n&lt;!ATTLIST xsl:variable \n  name %qname; #REQUIRED\n  select %expr; #IMPLIED\n&gt;\n\n&lt;!ELEMENT xsl:param %template;&gt;\n&lt;!ATTLIST xsl:param \n  name %qname; #REQUIRED\n  select %expr; #IMPLIED\n&gt;\n\n&lt;!ELEMENT xsl:text (#PCDATA)&gt;\n&lt;!ATTLIST xsl:text\n  disable-output-escaping (yes|no) \"no\"\n&gt;\n\n&lt;!ELEMENT xsl:processing-instruction %char-template;&gt;\n&lt;!ATTLIST xsl:processing-instruction \n  name %avt; #REQUIRED\n  %space-att;\n&gt;\n\n&lt;!ELEMENT xsl:element %template;&gt;\n&lt;!ATTLIST xsl:element \n  name %avt; #REQUIRED\n  namespace %avt; #IMPLIED\n  use-attribute-sets %qnames; #IMPLIED\n  %space-att;\n&gt;\n\n&lt;!ELEMENT xsl:attribute %char-template;&gt;\n&lt;!ATTLIST xsl:attribute \n  name %avt; #REQUIRED\n  namespace %avt; #IMPLIED\n  %space-att;\n&gt;\n\n&lt;!ELEMENT xsl:comment %char-template;&gt;\n&lt;!ATTLIST xsl:comment %space-att;&gt;\n\n&lt;!ELEMENT xsl:copy %template;&gt;\n&lt;!ATTLIST xsl:copy\n  %space-att;\n  use-attribute-sets %qnames; #IMPLIED\n&gt;\n\n&lt;!ELEMENT xsl:message %template;&gt;\n&lt;!ATTLIST xsl:message\n  %space-att;\n  terminate (yes|no) \"no\"\n&gt;\n\n&lt;!ELEMENT xsl:fallback %template;&gt;\n&lt;!ATTLIST xsl:fallback %space-att;&gt;</pre><h2><a name = \"section-Examples\" id = \"section-Examples\"></a>D Examples (Non-Normative)</h2><h3><a name = \"section-Document-Example\" id = \"section-Document-Example\"></a>D.1 Document Example</h3><p>This example is a stylesheet for transforming documents that conform to a\nsimple DTD into XHTML <a href = \"#XHTML\">[XHTML]</a>.  The DTD is:</p><pre>&lt;!ELEMENT doc (title, chapter*)&gt;\n&lt;!ELEMENT chapter (title, (para|note)*, section*)&gt;\n&lt;!ELEMENT section (title, (para|note)*)&gt;\n&lt;!ELEMENT title (#PCDATA|emph)*&gt;\n&lt;!ELEMENT para (#PCDATA|emph)*&gt;\n&lt;!ELEMENT note (#PCDATA|emph)*&gt;\n&lt;!ELEMENT emph (#PCDATA|emph)*&gt;</pre><p>The stylesheet is:</p><pre>&lt;xsl:stylesheet version=\"1.0\"\n                xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n                xmlns=\"http://www.w3.org/TR/xhtml1/strict\"&gt;\n\n&lt;xsl:strip-space elements=\"doc chapter section\"/&gt;\n&lt;xsl:output\n   method=\"xml\"\n   indent=\"yes\"\n   encoding=\"iso-8859-1\"\n/&gt;\n\n&lt;xsl:template match=\"doc\"&gt;\n &lt;html&gt;\n   &lt;head&gt;\n     &lt;title&gt;\n       &lt;xsl:value-of select=\"title\"/&gt;\n     &lt;/title&gt;\n   &lt;/head&gt;\n   &lt;body&gt;\n     &lt;xsl:apply-templates/&gt;\n   &lt;/body&gt;\n &lt;/html&gt;\n&lt;/xsl:template&gt;\n\n&lt;xsl:template match=\"doc/title\"&gt;\n  &lt;h1&gt;\n    &lt;xsl:apply-templates/&gt;\n  &lt;/h1&gt;\n&lt;/xsl:template&gt;\n\n&lt;xsl:template match=\"chapter/title\"&gt;\n  &lt;h2&gt;\n    &lt;xsl:apply-templates/&gt;\n  &lt;/h2&gt;\n&lt;/xsl:template&gt;\n\n&lt;xsl:template match=\"section/title\"&gt;\n  &lt;h3&gt;\n    &lt;xsl:apply-templates/&gt;\n  &lt;/h3&gt;\n&lt;/xsl:template&gt;\n\n&lt;xsl:template match=\"para\"&gt;\n  &lt;p&gt;\n    &lt;xsl:apply-templates/&gt;\n  &lt;/p&gt;\n&lt;/xsl:template&gt;\n\n&lt;xsl:template match=\"note\"&gt;\n  &lt;p class=\"note\"&gt;\n    &lt;b&gt;NOTE: &lt;/b&gt;\n    &lt;xsl:apply-templates/&gt;\n  &lt;/p&gt;\n&lt;/xsl:template&gt;\n\n&lt;xsl:template match=\"emph\"&gt;\n  &lt;em&gt;\n    &lt;xsl:apply-templates/&gt;\n  &lt;/em&gt;\n&lt;/xsl:template&gt;\n\n&lt;/xsl:stylesheet&gt;</pre><p>With the following input document</p><pre>&lt;!DOCTYPE doc SYSTEM \"doc.dtd\"&gt;\n&lt;doc&gt;\n&lt;title&gt;Document Title&lt;/title&gt;\n&lt;chapter&gt;\n&lt;title&gt;Chapter Title&lt;/title&gt;\n&lt;section&gt;\n&lt;title&gt;Section Title&lt;/title&gt;\n&lt;para&gt;This is a test.&lt;/para&gt;\n&lt;note&gt;This is a note.&lt;/note&gt;\n&lt;/section&gt;\n&lt;section&gt;\n&lt;title&gt;Another Section Title&lt;/title&gt;\n&lt;para&gt;This is &lt;emph&gt;another&lt;/emph&gt; test.&lt;/para&gt;\n&lt;note&gt;This is another note.&lt;/note&gt;\n&lt;/section&gt;\n&lt;/chapter&gt;\n&lt;/doc&gt;</pre><p>it would produce the following result</p><pre>&lt;?xml version=\"1.0\" encoding=\"iso-8859-1\"?&gt;\n&lt;html xmlns=\"http://www.w3.org/TR/xhtml1/strict\"&gt;\n&lt;head&gt;\n&lt;title&gt;Document Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Document Title&lt;/h1&gt;\n&lt;h2&gt;Chapter Title&lt;/h2&gt;\n&lt;h3&gt;Section Title&lt;/h3&gt;\n&lt;p&gt;This is a test.&lt;/p&gt;\n&lt;p class=\"note\"&gt;\n&lt;b&gt;NOTE: &lt;/b&gt;This is a note.&lt;/p&gt;\n&lt;h3&gt;Another Section Title&lt;/h3&gt;\n&lt;p&gt;This is &lt;em&gt;another&lt;/em&gt; test.&lt;/p&gt;\n&lt;p class=\"note\"&gt;\n&lt;b&gt;NOTE: &lt;/b&gt;This is another note.&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre><h3><a name = \"data-example\" id = \"data-example\"></a>D.2 Data Example</h3><p>This is an example of transforming some data represented in XML using\nthree different XSLT stylesheets to produce three different representations\nof the data, HTML, SVG and VRML.</p><p>The input data is:</p><pre>&lt;sales&gt;\n\n        &lt;division id=\"North\"&gt;\n                &lt;revenue&gt;10&lt;/revenue&gt;\n                &lt;growth&gt;9&lt;/growth&gt;\n                &lt;bonus&gt;7&lt;/bonus&gt;\n        &lt;/division&gt;\n\n        &lt;division id=\"South\"&gt;\n                &lt;revenue&gt;4&lt;/revenue&gt;\n                &lt;growth&gt;3&lt;/growth&gt;\n                &lt;bonus&gt;4&lt;/bonus&gt;\n        &lt;/division&gt;\n\n        &lt;division id=\"West\"&gt;\n                &lt;revenue&gt;6&lt;/revenue&gt;\n                &lt;growth&gt;-1.5&lt;/growth&gt;\n                &lt;bonus&gt;2&lt;/bonus&gt;\n        &lt;/division&gt;\n\n&lt;/sales&gt;</pre><p>The following stylesheet, which uses the simplified syntax described in <a href = \"#result-element-stylesheet\">[<b>2.3 Literal Result Element as\nStylesheet</b>]</a>, transforms the data into HTML:</p><pre>&lt;html xsl:version=\"1.0\"\n      xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n      lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;title&gt;Sales Results By Division&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;table border=\"1\"&gt;\n            &lt;tr&gt;\n                &lt;th&gt;Division&lt;/th&gt;\n                &lt;th&gt;Revenue&lt;/th&gt;\n                &lt;th&gt;Growth&lt;/th&gt;\n                &lt;th&gt;Bonus&lt;/th&gt;\n            &lt;/tr&gt;\n            &lt;xsl:for-each select=\"sales/division\"&gt;\n                &lt;!-- order the result by revenue --&gt;\n                &lt;xsl:sort select=\"revenue\"\n                          data-type=\"number\"\n                          order=\"descending\"/&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;\n                        &lt;em&gt;&lt;xsl:value-of select=\"@id\"/&gt;&lt;/em&gt;\n                    &lt;/td&gt;\n                    &lt;td&gt;\n                        &lt;xsl:value-of select=\"revenue\"/&gt;\n                    &lt;/td&gt;\n                    &lt;td&gt;\n                        &lt;!-- highlight negative growth in red --&gt;\n                        &lt;xsl:if test=\"growth &amp;lt; 0\"&gt;\n                             &lt;xsl:attribute name=\"style\"&gt;\n                                 &lt;xsl:text&gt;color:red&lt;/xsl:text&gt;\n                             &lt;/xsl:attribute&gt;\n                        &lt;/xsl:if&gt;\n                        &lt;xsl:value-of select=\"growth\"/&gt;\n                    &lt;/td&gt;\n                    &lt;td&gt;\n                        &lt;xsl:value-of select=\"bonus\"/&gt;\n                    &lt;/td&gt;\n                &lt;/tr&gt;\n            &lt;/xsl:for-each&gt;\n        &lt;/table&gt;\n    &lt;/body&gt;\n&lt;/html&gt;</pre><p>The HTML output is:</p><pre>&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\"&gt;\n&lt;title&gt;Sales Results By Division&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;table border=\"1\"&gt;\n&lt;tr&gt;\n&lt;th&gt;Division&lt;/th&gt;&lt;th&gt;Revenue&lt;/th&gt;&lt;th&gt;Growth&lt;/th&gt;&lt;th&gt;Bonus&lt;/th&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;em&gt;North&lt;/em&gt;&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;9&lt;/td&gt;&lt;td&gt;7&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;em&gt;West&lt;/em&gt;&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td style=\"color:red\"&gt;-1.5&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;em&gt;South&lt;/em&gt;&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/table&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre><p>The following stylesheet transforms the data into SVG:</p><pre>&lt;xsl:stylesheet version=\"1.0\"\n                xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n                xmlns=\"http://www.w3.org/Graphics/SVG/SVG-19990812.dtd\"&gt;\n\n&lt;xsl:output method=\"xml\" indent=\"yes\" media-type=\"image/svg\"/&gt;\n\n&lt;xsl:template match=\"/\"&gt;\n\n&lt;svg width = \"3in\" height=\"3in\"&gt;\n    &lt;g style = \"stroke: #000000\"&gt; \n        &lt;!-- draw the axes --&gt;\n        &lt;line x1=\"0\" x2=\"150\" y1=\"150\" y2=\"150\"/&gt;\n        &lt;line x1=\"0\" x2=\"0\" y1=\"0\" y2=\"150\"/&gt;\n        &lt;text x=\"0\" y=\"10\"&gt;Revenue&lt;/text&gt;\n        &lt;text x=\"150\" y=\"165\"&gt;Division&lt;/text&gt;\n        &lt;xsl:for-each select=\"sales/division\"&gt;\n            &lt;!-- define some useful variables --&gt;\n\n            &lt;!-- the bar's x position --&gt;\n            &lt;xsl:variable name=\"pos\"\n                          select=\"(position()*40)-30\"/&gt;\n\n            &lt;!-- the bar's height --&gt;\n            &lt;xsl:variable name=\"height\"\n                          select=\"revenue*10\"/&gt;\n\n            &lt;!-- the rectangle --&gt;\n            &lt;rect x=\"{$pos}\" y=\"{150-$height}\"\n                  width=\"20\" height=\"{$height}\"/&gt;\n\n            &lt;!-- the text label --&gt;\n            &lt;text x=\"{$pos}\" y=\"165\"&gt;\n                &lt;xsl:value-of select=\"@id\"/&gt;\n            &lt;/text&gt; \n\n            &lt;!-- the bar value --&gt;\n            &lt;text x=\"{$pos}\" y=\"{145-$height}\"&gt;\n                &lt;xsl:value-of select=\"revenue\"/&gt;\n            &lt;/text&gt;\n        &lt;/xsl:for-each&gt;\n    &lt;/g&gt;\n&lt;/svg&gt;\n\n&lt;/xsl:template&gt;\n&lt;/xsl:stylesheet&gt;</pre><p>The SVG output is:</p><pre>&lt;svg width=\"3in\" height=\"3in\"\n     xmlns=\"http://www.w3.org/Graphics/SVG/svg-19990412.dtd\"&gt;\n    &lt;g style=\"stroke: #000000\"&gt;\n        &lt;line x1=\"0\" x2=\"150\" y1=\"150\" y2=\"150\"/&gt;\n        &lt;line x1=\"0\" x2=\"0\" y1=\"0\" y2=\"150\"/&gt;\n        &lt;text x=\"0\" y=\"10\"&gt;Revenue&lt;/text&gt;\n        &lt;text x=\"150\" y=\"165\"&gt;Division&lt;/text&gt;\n        &lt;rect x=\"10\" y=\"50\" width=\"20\" height=\"100\"/&gt;\n        &lt;text x=\"10\" y=\"165\"&gt;North&lt;/text&gt;\n        &lt;text x=\"10\" y=\"45\"&gt;10&lt;/text&gt;\n        &lt;rect x=\"50\" y=\"110\" width=\"20\" height=\"40\"/&gt;\n        &lt;text x=\"50\" y=\"165\"&gt;South&lt;/text&gt;\n        &lt;text x=\"50\" y=\"105\"&gt;4&lt;/text&gt;\n        &lt;rect x=\"90\" y=\"90\" width=\"20\" height=\"60\"/&gt;\n        &lt;text x=\"90\" y=\"165\"&gt;West&lt;/text&gt;\n        &lt;text x=\"90\" y=\"85\"&gt;6&lt;/text&gt;\n    &lt;/g&gt;\n&lt;/svg&gt;</pre><p>The following stylesheet transforms the data into VRML:</p><pre>&lt;xsl:stylesheet version=\"1.0\"\n                xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"&gt;\n\n&lt;!-- generate text output as mime type model/vrml, using default charset --&gt;\n&lt;xsl:output method=\"text\" encoding=\"UTF-8\" media-type=\"model/vrml\"/&gt;  \n\n        &lt;xsl:template match=\"/\"&gt;#VRML V2.0 utf8 \n \n# externproto definition of a single bar element \nEXTERNPROTO bar [ \n  field SFInt32 x  \n  field SFInt32 y  \n  field SFInt32 z  \n  field SFString name  \n  ] \n  \"http://www.vrml.org/WorkingGroups/dbwork/barProto.wrl\" \n \n# inline containing the graph axes \nInline {  \n        url \"http://www.vrml.org/WorkingGroups/dbwork/barAxes.wrl\" \n        } \n        \n                &lt;xsl:for-each select=\"sales/division\"&gt;\nbar {\n        x &lt;xsl:value-of select=\"revenue\"/&gt;\n        y &lt;xsl:value-of select=\"growth\"/&gt;\n        z &lt;xsl:value-of select=\"bonus\"/&gt;\n        name \"&lt;xsl:value-of select=\"@id\"/&gt;\" \n        }\n                &lt;/xsl:for-each&gt;\n        \n        &lt;/xsl:template&gt; \n \n&lt;/xsl:stylesheet&gt;</pre><p>The VRML output is:</p><pre>#VRML V2.0 utf8 \n \n# externproto definition of a single bar element \nEXTERNPROTO bar [ \n  field SFInt32 x  \n  field SFInt32 y  \n  field SFInt32 z  \n  field SFString name  \n  ] \n  \"http://www.vrml.org/WorkingGroups/dbwork/barProto.wrl\" \n \n# inline containing the graph axes \nInline {  \n        url \"http://www.vrml.org/WorkingGroups/dbwork/barAxes.wrl\" \n        } \n        \n                \nbar {\n        x 10\n        y 9\n        z 7\n        name \"North\" \n        }\n                \nbar {\n        x 4\n        y 3\n        z 4\n        name \"South\" \n        }\n                \nbar {\n        x 6\n        y -1.5\n        z 2\n        name \"West\" \n        }</pre><h2><a name = \"section-Acknowledgements\" id = \"section-Acknowledgements\"></a>E Acknowledgements\n(Non-Normative)</h2><p>The following have contributed to authoring this draft:</p><ul>\n  <li>Daniel Lipkin, Saba</li>\n  <li>Jonathan Marsh, Microsoft</li>\n  <li>Henry Thompson, University of Edinburgh</li>\n  <li>Norman Walsh, Arbortext</li>\n  <li>Steve Zilles, Adobe</li>\n</ul><p>This specification was developed and approved for publication by the W3C\nXSL Working Group (WG). WG approval of this specification does not\nnecessarily imply that all WG members voted for its approval. The current\nmembers of the XSL WG are:</p><h2><a name = \"section-Changes-from-Proposed-Recommendation\" id = \"section-Changes-from-Proposed-Recommendation\"></a>F Changes from\nProposed Recommendation (Non-Normative)</h2><p>The following are the changes since the Proposed Recommendation:</p><ul>\n  <li><p>The <code>xsl:version</code> attribute is required on a literal\n    result element used as a stylesheet (see <a href = \"#result-element-stylesheet\">[<b>2.3 Literal Result Element as\n    Stylesheet</b>]</a>).</p>\n  </li>\n  <li><p>The <code>data-type</code> attribute on <code>xsl:sort</code> can\n    use a prefixed name to specify a data-type not defined by XSLT (see <a href = \"#sorting\">[<b>10 Sorting</b>]</a>).</p>\n  </li>\n</ul><h2><a name = \"section-Features-under-Consideration-for-Future-Versions-of-XSLT\" id = \"section-Features-under-Consideration-for-Future-Versions-of-XSLT\"></a>G\nFeatures under Consideration for Future Versions of XSLT (Non-Normative)</h2><p>The following features are under consideration for versions of XSLT after\nXSLT 1.0:</p><ul>\n  <li><p>a conditional expression;</p>\n  </li>\n  <li><p>support for XML Schema datatypes and archetypes;</p>\n  </li>\n  <li><p>support for something like style rules in the original XSL\n    submission;</p>\n  </li>\n  <li><p>an attribute to control the default namespace for names occurring in\n    XSLT attributes;</p>\n  </li>\n  <li><p>support for entity references;</p>\n  </li>\n  <li><p>support for DTDs in the data model;</p>\n  </li>\n  <li><p>support for notations in the data model;</p>\n  </li>\n  <li><p>a way to get back from an element to the elements that reference it\n    (e.g. by IDREF attributes);</p>\n  </li>\n  <li><p>an easier way to get an ID or key in another document;</p>\n  </li>\n  <li><p>support for regular expressions for matching against any or all of\n    text nodes, attribute values, attribute names, element type names;</p>\n  </li>\n  <li><p>case-insensitive comparisons;</p>\n  </li>\n  <li><p>normalization of strings before comparison, for example for\n    compatibility characters;</p>\n  </li>\n  <li><p>a function <code>string resolve(node-set)</code> function that\n    treats the value of the argument as a relative URI and turns it into an\n    absolute URI using the base URI of the node;</p>\n  </li>\n  <li><p>multiple result documents;</p>\n  </li>\n  <li><p>defaulting the <code>select</code> attribute on\n    <code>xsl:value-of</code> to the current node;</p>\n  </li>\n  <li><p>an attribute on <code>xsl:attribute</code> to control how the\n    attribute value is normalized;</p>\n  </li>\n  <li><p>additional attributes on <code>xsl:sort</code> to provide further\n    control over sorting, such as relative order of scripts;</p>\n  </li>\n  <li><p>a way to put the text of a resource identified by a URI into the\n    result tree;</p>\n  </li>\n  <li><p>allow unions in steps (e.g. <code>foo/(bar|baz)</code>);</p>\n  </li>\n  <li><p>allow for result tree fragments all operations that are allowed for\n    node-sets;</p>\n  </li>\n  <li><p>a way to group together consecutive nodes having duplicate\n    subelements or attributes;</p>\n  </li>\n  <li><p>features to make handling of the HTML <code>style</code> attribute\n    more convenient.</p>\n  </li>\n</ul>",
		"searchableItems": [
			{
				"name": "apply-imports",
				"domId": "XSLT_element-apply-imports"
			},
			{
				"name": "apply-templates",
				"domId": "XSLT_element-apply-templates"
			},
			{
				"name": "attribute",
				"domId": "XSLT_element-attribute"
			},
			{
				"name": "attribute-set",
				"domId": "XSLT_element-attribute-set"
			},
			{
				"name": "call-template",
				"domId": "XSLT_element-call-template"
			},
			{
				"name": "choose",
				"domId": "XSLT_element-choose"
			},
			{
				"name": "comment",
				"domId": "XSLT_element-comment"
			},
			{
				"name": "copy",
				"domId": "XSLT_element-copy"
			},
			{
				"name": "copy-of",
				"domId": "XSLT_element-copy-of"
			},
			{
				"name": "decimal-format",
				"domId": "XSLT_element-decimal-format"
			},
			{
				"name": "element",
				"domId": "XSLT_element-element"
			},
			{
				"name": "fallback",
				"domId": "XSLT_element-fallback"
			},
			{
				"name": "for-each",
				"domId": "XSLT_element-for-each"
			},
			{
				"name": "if",
				"domId": "XSLT_element-if"
			},
			{
				"name": "import",
				"domId": "XSLT_element-import"
			},
			{
				"name": "include",
				"domId": "XSLT_element-include"
			},
			{
				"name": "key",
				"domId": "XSLT_element-key"
			},
			{
				"name": "message",
				"domId": "XSLT_element-message"
			},
			{
				"name": "namespace-alias",
				"domId": "XSLT_element-namespace-alias"
			},
			{
				"name": "number",
				"domId": "XSLT_element-number"
			},
			{
				"name": "otherwise",
				"domId": "XSLT_element-otherwise"
			},
			{
				"name": "output",
				"domId": "XSLT_element-output"
			},
			{
				"name": "param",
				"domId": "XSLT_element-param"
			},
			{
				"name": "preserve-space",
				"domId": "XSLT_element-preserve-space"
			},
			{
				"name": "processing-instruction",
				"domId": "XSLT_element-processing-instruction"
			},
			{
				"name": "sort",
				"domId": "XSLT_element-sort"
			},
			{
				"name": "strip-space",
				"domId": "XSLT_element-strip-space"
			},
			{
				"name": "stylesheet",
				"domId": "XSLT_element-stylesheet"
			},
			{
				"name": "template",
				"domId": "XSLT_element-template"
			},
			{
				"name": "text",
				"domId": "XSLT_element-text"
			},
			{
				"name": "transform",
				"domId": "XSLT_element-transform"
			},
			{
				"name": "value-of",
				"domId": "XSLT_element-value-of"
			},
			{
				"name": "variable",
				"domId": "XSLT_element-variable"
			},
			{
				"name": "when",
				"domId": "XSLT_element-when"
			},
			{
				"name": "with-param",
				"domId": "XSLT_element-with-param"
			}
		]
	}
]